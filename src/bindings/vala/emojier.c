/* emojier.c generated by valac 0.38.2, the Vala compiler
 * generated from emojier.vala, do not modify */

/* vim:set et sts=4 sw=4:
 *
 * ibus - The Input Bus
 *
 * Copyright (c) 2017 Takao Fujiwara <takao.fujiwara1@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <ibus.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>
#include <glib/gi18n-lib.h>
#include <gio/gio.h>
#include <locale.h>
#include <atk/atk.h>
#include <config.h>
#include <cairo.h>
#include <pango/pango.h>


#define TYPE_IBUS_EMOJIER (ibus_emojier_get_type ())
#define IBUS_EMOJIER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IBUS_EMOJIER, IBusEmojier))
#define IBUS_EMOJIER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IBUS_EMOJIER, IBusEmojierClass))
#define IS_IBUS_EMOJIER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IBUS_EMOJIER))
#define IS_IBUS_EMOJIER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IBUS_EMOJIER))
#define IBUS_EMOJIER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IBUS_EMOJIER, IBusEmojierClass))

typedef struct _IBusEmojier IBusEmojier;
typedef struct _IBusEmojierClass IBusEmojierClass;
typedef struct _IBusEmojierPrivate IBusEmojierPrivate;

#define TYPE_THEMED_RGBA (themed_rgba_get_type ())
#define THEMED_RGBA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_THEMED_RGBA, ThemedRGBA))
#define THEMED_RGBA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_THEMED_RGBA, ThemedRGBAClass))
#define IS_THEMED_RGBA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_THEMED_RGBA))
#define IS_THEMED_RGBA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_THEMED_RGBA))
#define THEMED_RGBA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_THEMED_RGBA, ThemedRGBAClass))

typedef struct _ThemedRGBA ThemedRGBA;
typedef struct _ThemedRGBAClass ThemedRGBAClass;

#define IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX (ibus_emojier_etitle_label_box_get_type ())
#define IBUS_EMOJIER_ETITLE_LABEL_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX, IBusEmojierETitleLabelBox))
#define IBUS_EMOJIER_ETITLE_LABEL_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX, IBusEmojierETitleLabelBoxClass))
#define IBUS_EMOJIER_IS_ETITLE_LABEL_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX))
#define IBUS_EMOJIER_IS_ETITLE_LABEL_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX))
#define IBUS_EMOJIER_ETITLE_LABEL_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX, IBusEmojierETitleLabelBoxClass))

typedef struct _IBusEmojierETitleLabelBox IBusEmojierETitleLabelBox;
typedef struct _IBusEmojierETitleLabelBoxClass IBusEmojierETitleLabelBoxClass;

#define IBUS_EMOJIER_TYPE_EENTRY (ibus_emojier_eentry_get_type ())
#define IBUS_EMOJIER_EENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EENTRY, IBusEmojierEEntry))
#define IBUS_EMOJIER_EENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EENTRY, IBusEmojierEEntryClass))
#define IBUS_EMOJIER_IS_EENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EENTRY))
#define IBUS_EMOJIER_IS_EENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EENTRY))
#define IBUS_EMOJIER_EENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EENTRY, IBusEmojierEEntryClass))

typedef struct _IBusEmojierEEntry IBusEmojierEEntry;
typedef struct _IBusEmojierEEntryClass IBusEmojierEEntryClass;

#define IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW (ibus_emojier_escrolled_window_get_type ())
#define IBUS_EMOJIER_ESCROLLED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW, IBusEmojierEScrolledWindow))
#define IBUS_EMOJIER_ESCROLLED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW, IBusEmojierEScrolledWindowClass))
#define IBUS_EMOJIER_IS_ESCROLLED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW))
#define IBUS_EMOJIER_IS_ESCROLLED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW))
#define IBUS_EMOJIER_ESCROLLED_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW, IBusEmojierEScrolledWindowClass))

typedef struct _IBusEmojierEScrolledWindow IBusEmojierEScrolledWindow;
typedef struct _IBusEmojierEScrolledWindowClass IBusEmojierEScrolledWindowClass;

#define IBUS_EMOJIER_TYPE_ELIST_BOX (ibus_emojier_elist_box_get_type ())
#define IBUS_EMOJIER_ELIST_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_ELIST_BOX, IBusEmojierEListBox))
#define IBUS_EMOJIER_ELIST_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_ELIST_BOX, IBusEmojierEListBoxClass))
#define IBUS_EMOJIER_IS_ELIST_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_ELIST_BOX))
#define IBUS_EMOJIER_IS_ELIST_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_ELIST_BOX))
#define IBUS_EMOJIER_ELIST_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_ELIST_BOX, IBusEmojierEListBoxClass))

typedef struct _IBusEmojierEListBox IBusEmojierEListBox;
typedef struct _IBusEmojierEListBoxClass IBusEmojierEListBoxClass;
enum  {
	IBUS_EMOJIER_DUMMY_PROPERTY,
	IBUS_EMOJIER_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_properties[IBUS_EMOJIER_LAST_PROPERTY];

#define IBUS_EMOJIER_TYPE_TRAVEL_DIRECTION (ibus_emojier_travel_direction_get_type ())
#define _themed_rgba_unref0(var) ((var == NULL) ? NULL : (var = (themed_rgba_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define __g_slist_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_slist_free__g_object_unref0_ (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define __g_slist_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_slist_free__g_free0_ (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

#define IBUS_EMOJIER_TYPE_EBOX_ROW (ibus_emojier_ebox_row_get_type ())
#define IBUS_EMOJIER_EBOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRow))
#define IBUS_EMOJIER_EBOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRowClass))
#define IBUS_EMOJIER_IS_EBOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EBOX_ROW))
#define IBUS_EMOJIER_IS_EBOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EBOX_ROW))
#define IBUS_EMOJIER_EBOX_ROW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRowClass))

typedef struct _IBusEmojierEBoxRow IBusEmojierEBoxRow;
typedef struct _IBusEmojierEBoxRowClass IBusEmojierEBoxRowClass;

#define IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX (ibus_emojier_epadded_label_box_get_type ())
#define IBUS_EMOJIER_EPADDED_LABEL_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX, IBusEmojierEPaddedLabelBox))
#define IBUS_EMOJIER_EPADDED_LABEL_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX, IBusEmojierEPaddedLabelBoxClass))
#define IBUS_EMOJIER_IS_EPADDED_LABEL_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX))
#define IBUS_EMOJIER_IS_EPADDED_LABEL_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX))
#define IBUS_EMOJIER_EPADDED_LABEL_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX, IBusEmojierEPaddedLabelBoxClass))

typedef struct _IBusEmojierEPaddedLabelBox IBusEmojierEPaddedLabelBox;
typedef struct _IBusEmojierEPaddedLabelBoxClass IBusEmojierEPaddedLabelBoxClass;

#define IBUS_EMOJIER_TYPE_EGRID (ibus_emojier_egrid_get_type ())
#define IBUS_EMOJIER_EGRID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EGRID, IBusEmojierEGrid))
#define IBUS_EMOJIER_EGRID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EGRID, IBusEmojierEGridClass))
#define IBUS_EMOJIER_IS_EGRID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EGRID))
#define IBUS_EMOJIER_IS_EGRID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EGRID))
#define IBUS_EMOJIER_EGRID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EGRID, IBusEmojierEGridClass))

typedef struct _IBusEmojierEGrid IBusEmojierEGrid;
typedef struct _IBusEmojierEGridClass IBusEmojierEGridClass;
typedef struct _Block4Data Block4Data;

#define IBUS_EMOJIER_TYPE_ESELECTED_LABEL (ibus_emojier_eselected_label_get_type ())
#define IBUS_EMOJIER_ESELECTED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_ESELECTED_LABEL, IBusEmojierESelectedLabel))
#define IBUS_EMOJIER_ESELECTED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_ESELECTED_LABEL, IBusEmojierESelectedLabelClass))
#define IBUS_EMOJIER_IS_ESELECTED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_ESELECTED_LABEL))
#define IBUS_EMOJIER_IS_ESELECTED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_ESELECTED_LABEL))
#define IBUS_EMOJIER_ESELECTED_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_ESELECTED_LABEL, IBusEmojierESelectedLabelClass))

typedef struct _IBusEmojierESelectedLabel IBusEmojierESelectedLabel;
typedef struct _IBusEmojierESelectedLabelClass IBusEmojierESelectedLabelClass;

#define IBUS_EMOJIER_TYPE_EGOLD_LABEL (ibus_emojier_egold_label_get_type ())
#define IBUS_EMOJIER_EGOLD_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EGOLD_LABEL, IBusEmojierEGoldLabel))
#define IBUS_EMOJIER_EGOLD_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EGOLD_LABEL, IBusEmojierEGoldLabelClass))
#define IBUS_EMOJIER_IS_EGOLD_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EGOLD_LABEL))
#define IBUS_EMOJIER_IS_EGOLD_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EGOLD_LABEL))
#define IBUS_EMOJIER_EGOLD_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EGOLD_LABEL, IBusEmojierEGoldLabelClass))

typedef struct _IBusEmojierEGoldLabel IBusEmojierEGoldLabel;
typedef struct _IBusEmojierEGoldLabelClass IBusEmojierEGoldLabelClass;

#define IBUS_EMOJIER_TYPE_EWHITE_LABEL (ibus_emojier_ewhite_label_get_type ())
#define IBUS_EMOJIER_EWHITE_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EWHITE_LABEL, IBusEmojierEWhiteLabel))
#define IBUS_EMOJIER_EWHITE_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EWHITE_LABEL, IBusEmojierEWhiteLabelClass))
#define IBUS_EMOJIER_IS_EWHITE_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EWHITE_LABEL))
#define IBUS_EMOJIER_IS_EWHITE_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EWHITE_LABEL))
#define IBUS_EMOJIER_EWHITE_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EWHITE_LABEL, IBusEmojierEWhiteLabelClass))

typedef struct _IBusEmojierEWhiteLabel IBusEmojierEWhiteLabel;
typedef struct _IBusEmojierEWhiteLabelClass IBusEmojierEWhiteLabelClass;
#define __vala_GdkEventMotion_free0(var) ((var == NULL) ? NULL : (var = (_vala_GdkEventMotion_free (var), NULL)))
#define __vala_GdkEvent_free0(var) ((var == NULL) ? NULL : (var = (_vala_GdkEvent_free (var), NULL)))
#define __vala_PangoFontDescription_free0(var) ((var == NULL) ? NULL : (var = (_vala_PangoFontDescription_free (var), NULL)))
typedef struct _IBusEmojierEEntryPrivate IBusEmojierEEntryPrivate;
enum  {
	IBUS_EMOJIER_EENTRY_DUMMY_PROPERTY,
	IBUS_EMOJIER_EENTRY_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_eentry_properties[IBUS_EMOJIER_EENTRY_LAST_PROPERTY];
typedef struct _IBusEmojierEListBoxPrivate IBusEmojierEListBoxPrivate;
enum  {
	IBUS_EMOJIER_ELIST_BOX_DUMMY_PROPERTY,
	IBUS_EMOJIER_ELIST_BOX_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_elist_box_properties[IBUS_EMOJIER_ELIST_BOX_LAST_PROPERTY];
typedef struct _IBusEmojierEBoxRowPrivate IBusEmojierEBoxRowPrivate;
enum  {
	IBUS_EMOJIER_EBOX_ROW_DUMMY_PROPERTY,
	IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY,
	IBUS_EMOJIER_EBOX_ROW_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_ebox_row_properties[IBUS_EMOJIER_EBOX_ROW_LAST_PROPERTY];
typedef struct _IBusEmojierEScrolledWindowPrivate IBusEmojierEScrolledWindowPrivate;
enum  {
	IBUS_EMOJIER_ESCROLLED_WINDOW_DUMMY_PROPERTY,
	IBUS_EMOJIER_ESCROLLED_WINDOW_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_escrolled_window_properties[IBUS_EMOJIER_ESCROLLED_WINDOW_LAST_PROPERTY];
typedef struct _IBusEmojierEGridPrivate IBusEmojierEGridPrivate;
enum  {
	IBUS_EMOJIER_EGRID_DUMMY_PROPERTY,
	IBUS_EMOJIER_EGRID_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_egrid_properties[IBUS_EMOJIER_EGRID_LAST_PROPERTY];
typedef struct _IBusEmojierEWhiteLabelPrivate IBusEmojierEWhiteLabelPrivate;
enum  {
	IBUS_EMOJIER_EWHITE_LABEL_DUMMY_PROPERTY,
	IBUS_EMOJIER_EWHITE_LABEL_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_ewhite_label_properties[IBUS_EMOJIER_EWHITE_LABEL_LAST_PROPERTY];
typedef struct _IBusEmojierESelectedLabelPrivate IBusEmojierESelectedLabelPrivate;
enum  {
	IBUS_EMOJIER_ESELECTED_LABEL_DUMMY_PROPERTY,
	IBUS_EMOJIER_ESELECTED_LABEL_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_eselected_label_properties[IBUS_EMOJIER_ESELECTED_LABEL_LAST_PROPERTY];
typedef struct _IBusEmojierEGoldLabelPrivate IBusEmojierEGoldLabelPrivate;
enum  {
	IBUS_EMOJIER_EGOLD_LABEL_DUMMY_PROPERTY,
	IBUS_EMOJIER_EGOLD_LABEL_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_egold_label_properties[IBUS_EMOJIER_EGOLD_LABEL_LAST_PROPERTY];

#define IBUS_EMOJIER_TYPE_EPADDED_LABEL (ibus_emojier_epadded_label_get_type ())
#define IBUS_EMOJIER_EPADDED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL, IBusEmojierEPaddedLabel))
#define IBUS_EMOJIER_EPADDED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EPADDED_LABEL, IBusEmojierEPaddedLabelClass))
#define IBUS_EMOJIER_IS_EPADDED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL))
#define IBUS_EMOJIER_IS_EPADDED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EPADDED_LABEL))
#define IBUS_EMOJIER_EPADDED_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL, IBusEmojierEPaddedLabelClass))

typedef struct _IBusEmojierEPaddedLabel IBusEmojierEPaddedLabel;
typedef struct _IBusEmojierEPaddedLabelClass IBusEmojierEPaddedLabelClass;
typedef struct _IBusEmojierEPaddedLabelPrivate IBusEmojierEPaddedLabelPrivate;
enum  {
	IBUS_EMOJIER_EPADDED_LABEL_DUMMY_PROPERTY,
	IBUS_EMOJIER_EPADDED_LABEL_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_epadded_label_properties[IBUS_EMOJIER_EPADDED_LABEL_LAST_PROPERTY];
typedef struct _IBusEmojierEPaddedLabelBoxPrivate IBusEmojierEPaddedLabelBoxPrivate;
enum  {
	IBUS_EMOJIER_EPADDED_LABEL_BOX_DUMMY_PROPERTY,
	IBUS_EMOJIER_EPADDED_LABEL_BOX_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_epadded_label_box_properties[IBUS_EMOJIER_EPADDED_LABEL_BOX_LAST_PROPERTY];

#define TYPE_ICON_WIDGET (icon_widget_get_type ())
#define ICON_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ICON_WIDGET, IconWidget))
#define ICON_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ICON_WIDGET, IconWidgetClass))
#define IS_ICON_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ICON_WIDGET))
#define IS_ICON_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ICON_WIDGET))
#define ICON_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ICON_WIDGET, IconWidgetClass))

typedef struct _IconWidget IconWidget;
typedef struct _IconWidgetClass IconWidgetClass;
typedef struct _IBusEmojierETitleLabelBoxPrivate IBusEmojierETitleLabelBoxPrivate;
enum  {
	IBUS_EMOJIER_ETITLE_LABEL_BOX_DUMMY_PROPERTY,
	IBUS_EMOJIER_ETITLE_LABEL_BOX_LAST_PROPERTY
};
static GParamSpec* ibus_emojier_etitle_label_box_properties[IBUS_EMOJIER_ETITLE_LABEL_BOX_LAST_PROPERTY];
enum  {
	IBUS_EMOJIER_CANDIDATE_CLICKED_SIGNAL,
	IBUS_EMOJIER_LAST_SIGNAL
};
static guint ibus_emojier_signals[IBUS_EMOJIER_LAST_SIGNAL] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _IBusEmojier {
	GtkApplicationWindow parent_instance;
	IBusEmojierPrivate * priv;
};

struct _IBusEmojierClass {
	GtkApplicationWindowClass parent_class;
};

struct _IBusEmojierPrivate {
	ThemedRGBA* m_rgba;
	GtkBox* m_vbox;
	IBusEmojierETitleLabelBox* m_title;
	IBusEmojierEEntry* m_entry;
	gchar* m_backward;
	gint m_backward_index;
	IBusEmojierEScrolledWindow* m_scrolled_window;
	IBusEmojierEListBox* m_list_box;
	gboolean m_is_running;
	gchar* m_input_context_path;
	GMainLoop* m_loop;
	gchar* m_result;
	gchar* m_unicode_point;
	gboolean m_candidate_panel_is_visible;
	gint m_category_active_index;
	IBusLookupTable* m_lookup_table;
	GtkLabel** m_candidates;
	gint m_candidates_length1;
	gint _m_candidates_size_;
	gboolean m_enter_notify_enable;
	guint m_entry_notify_show_id;
	guint m_entry_notify_disable_id;
};

typedef enum  {
	IBUS_EMOJIER_TRAVEL_DIRECTION_NONE,
	IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD
} IBusEmojierTravelDirection;

struct _Block4Data {
	int _ref_count_;
	IBusEmojier* self;
	guint index;
};

struct _IBusEmojierEEntry {
	GtkSearchEntry parent_instance;
	IBusEmojierEEntryPrivate * priv;
};

struct _IBusEmojierEEntryClass {
	GtkSearchEntryClass parent_class;
};

struct _IBusEmojierEListBox {
	GtkListBox parent_instance;
	IBusEmojierEListBoxPrivate * priv;
};

struct _IBusEmojierEListBoxClass {
	GtkListBoxClass parent_class;
};

struct _IBusEmojierEBoxRow {
	GtkListBoxRow parent_instance;
	IBusEmojierEBoxRowPrivate * priv;
};

struct _IBusEmojierEBoxRowClass {
	GtkListBoxRowClass parent_class;
};

struct _IBusEmojierEBoxRowPrivate {
	gchar* _text;
};

struct _IBusEmojierEScrolledWindow {
	GtkScrolledWindow parent_instance;
	IBusEmojierEScrolledWindowPrivate * priv;
};

struct _IBusEmojierEScrolledWindowClass {
	GtkScrolledWindowClass parent_class;
};

struct _IBusEmojierEGrid {
	GtkGrid parent_instance;
	IBusEmojierEGridPrivate * priv;
};

struct _IBusEmojierEGridClass {
	GtkGridClass parent_class;
};

struct _IBusEmojierEWhiteLabel {
	GtkLabel parent_instance;
	IBusEmojierEWhiteLabelPrivate * priv;
};

struct _IBusEmojierEWhiteLabelClass {
	GtkLabelClass parent_class;
};

struct _IBusEmojierESelectedLabel {
	GtkLabel parent_instance;
	IBusEmojierESelectedLabelPrivate * priv;
};

struct _IBusEmojierESelectedLabelClass {
	GtkLabelClass parent_class;
};

struct _IBusEmojierEGoldLabel {
	GtkLabel parent_instance;
	IBusEmojierEGoldLabelPrivate * priv;
};

struct _IBusEmojierEGoldLabelClass {
	GtkLabelClass parent_class;
};

struct _IBusEmojierEPaddedLabel {
	GtkLabel parent_instance;
	IBusEmojierEPaddedLabelPrivate * priv;
};

struct _IBusEmojierEPaddedLabelClass {
	GtkLabelClass parent_class;
};

struct _IBusEmojierEPaddedLabelBox {
	GtkBox parent_instance;
	IBusEmojierEPaddedLabelBoxPrivate * priv;
};

struct _IBusEmojierEPaddedLabelBoxClass {
	GtkBoxClass parent_class;
};

struct _IBusEmojierETitleLabelBox {
	GtkHeaderBar parent_instance;
	IBusEmojierETitleLabelBoxPrivate * priv;
};

struct _IBusEmojierETitleLabelBoxClass {
	GtkHeaderBarClass parent_class;
};

struct _IBusEmojierETitleLabelBoxPrivate {
	GtkLabel* m_lang_label;
};


static gpointer ibus_emojier_parent_class = NULL;
static gchar* ibus_emojier_m_current_lang_id;
static gchar* ibus_emojier_m_current_lang_id = NULL;
static gchar* ibus_emojier_m_emoji_font_family;
static gchar* ibus_emojier_m_emoji_font_family = NULL;
static gint ibus_emojier_m_emoji_font_size;
static gint ibus_emojier_m_emoji_font_size = 0;
static gchar** ibus_emojier_m_favorites;
static gint ibus_emojier_m_favorites_length1;
static gchar** ibus_emojier_m_favorites = NULL;
static gint ibus_emojier_m_favorites_length1 = 0;
static gint _ibus_emojier_m_favorites_size_ = 0;
static gchar** ibus_emojier_m_favorite_annotations;
static gint ibus_emojier_m_favorite_annotations_length1;
static gchar** ibus_emojier_m_favorite_annotations = NULL;
static gint ibus_emojier_m_favorite_annotations_length1 = 0;
static gint _ibus_emojier_m_favorite_annotations_size_ = 0;
static gint ibus_emojier_m_emoji_max_seq_len;
static gint ibus_emojier_m_emoji_max_seq_len = 0;
static gboolean ibus_emojier_m_has_partial_match;
static gboolean ibus_emojier_m_has_partial_match = FALSE;
static guint ibus_emojier_m_partial_match_length;
static guint ibus_emojier_m_partial_match_length = 0U;
static guint ibus_emojier_m_partial_match_condition;
static guint ibus_emojier_m_partial_match_condition = 0U;
static gboolean ibus_emojier_m_show_emoji_variant;
static gboolean ibus_emojier_m_show_emoji_variant = FALSE;
static GHashTable* ibus_emojier_m_annotation_to_emojis_dict;
static GHashTable* ibus_emojier_m_annotation_to_emojis_dict = NULL;
static GHashTable* ibus_emojier_m_emoji_to_data_dict;
static GHashTable* ibus_emojier_m_emoji_to_data_dict = NULL;
static GHashTable* ibus_emojier_m_category_to_emojis_dict;
static GHashTable* ibus_emojier_m_category_to_emojis_dict = NULL;
static GHashTable* ibus_emojier_m_emoji_to_emoji_variants_dict;
static GHashTable* ibus_emojier_m_emoji_to_emoji_variants_dict = NULL;
extern gdouble ibus_emojier_m_mouse_x;
gdouble ibus_emojier_m_mouse_x = 0.0;
extern gdouble ibus_emojier_m_mouse_y;
gdouble ibus_emojier_m_mouse_y = 0.0;
static gpointer ibus_emojier_eentry_parent_class = NULL;
static gpointer ibus_emojier_elist_box_parent_class = NULL;
static gpointer ibus_emojier_ebox_row_parent_class = NULL;
static gpointer ibus_emojier_escrolled_window_parent_class = NULL;
static gpointer ibus_emojier_egrid_parent_class = NULL;
static gpointer ibus_emojier_ewhite_label_parent_class = NULL;
static gpointer ibus_emojier_eselected_label_parent_class = NULL;
static gpointer ibus_emojier_egold_label_parent_class = NULL;
static gpointer ibus_emojier_epadded_label_parent_class = NULL;
static gpointer ibus_emojier_epadded_label_box_parent_class = NULL;
static gpointer ibus_emojier_etitle_label_box_parent_class = NULL;

GType ibus_emojier_get_type (void) G_GNUC_CONST;
gpointer themed_rgba_ref (gpointer instance);
void themed_rgba_unref (gpointer instance);
GParamSpec* param_spec_themed_rgba (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_themed_rgba (GValue* value, gpointer v_object);
void value_take_themed_rgba (GValue* value, gpointer v_object);
gpointer value_get_themed_rgba (const GValue* value);
GType themed_rgba_get_type (void) G_GNUC_CONST;
static GType ibus_emojier_etitle_label_box_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GType ibus_emojier_eentry_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GType ibus_emojier_escrolled_window_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GType ibus_emojier_elist_box_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define IBUS_EMOJIER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_IBUS_EMOJIER, IBusEmojierPrivate))
static GType ibus_emojier_travel_direction_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define IBUS_EMOJIER_EMOJI_GRID_PAGE ((guint) 10)
#define IBUS_EMOJIER_EMOJI_CATEGORY_FAVORITES N_ ("Favorites")
#define IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS N_ ("Others")
IBusEmojier* ibus_emojier_new (void);
IBusEmojier* ibus_emojier_construct (GType object_type);
static void ibus_emojier_check_action_variant_cb (IBusEmojier* self, GSimpleAction* action, GVariant* parameter);
static void _ibus_emojier_check_action_variant_cb_g_simple_action_activate (GSimpleAction* _sender, GVariant* parameter, gpointer self);
ThemedRGBA* themed_rgba_new (GtkWidget* widget);
ThemedRGBA* themed_rgba_construct (GType object_type, GtkWidget* widget);
GdkRGBA* themed_rgba_get_normal_bg (ThemedRGBA* self);
GdkRGBA* themed_rgba_get_selected_fg (ThemedRGBA* self);
GdkRGBA* themed_rgba_get_selected_bg (ThemedRGBA* self);
static IBusEmojierETitleLabelBox* ibus_emojier_etitle_label_box_new (const gchar* title);
static IBusEmojierETitleLabelBox* ibus_emojier_etitle_label_box_construct (GType object_type, const gchar* title);
static IBusEmojierEEntry* ibus_emojier_eentry_new (void);
static IBusEmojierEEntry* ibus_emojier_eentry_construct (GType object_type);
static void __lambda20_ (IBusEmojier* self);
static void ibus_emojier_update_candidate_window (IBusEmojier* self);
static void ___lambda20__gtk_editable_changed (GtkEditable* _sender, gpointer self);
static void __lambda21_ (IBusEmojier* self, GtkEntryIconPosition icon_pos, GdkEvent* event);
static void ibus_emojier_hide_candidate_panel (IBusEmojier* self);
static void ___lambda21__gtk_entry_icon_release (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self);
static void __lambda22_ (IBusEmojier* self);
static void ___lambda22__gtk_widget_hide (GtkWidget* _sender, gpointer self);
static void __lambda23_ (IBusEmojier* self, guint i, guint b, guint s);
static void ibus_emojier_candidate_panel_select_index (IBusEmojier* self, guint index);
static void ___lambda23__ibus_emojier_candidate_clicked (IBusEmojier* _sender, guint index, guint button, guint state, gpointer self);
static void ibus_emojier_reload_emoji_dict (void);
static void ibus_emojier_init_emoji_dict (void);
static void ibus_emojier_make_emoji_dict (const gchar* lang);
void ibus_emojier_update_favorite_emoji_dict (void);
static void _g_free0_ (gpointer var);
static inline void _g_slist_free__g_free0_ (GSList* self);
static void __g_slist_free__g_free0_0_ (gpointer var);
static void _g_object_unref0_ (gpointer var);
static inline void _g_slist_free__g_object_unref0_ (GSList* self);
static void ibus_emojier_update_emoji_to_data_dict (IBusEmojiData* data, const gchar* lang);
static void ibus_emojier_update_annotation_to_emojis_dict (IBusEmojiData* data);
static void ibus_emojier_update_category_to_emojis_dict (IBusEmojiData* data, const gchar* lang);
static gpointer _g_strdup_gcopy_func (gconstpointer src, gpointer self);
static gchar* ibus_emojier_utf8_code_point (const gchar* str);
static gchar* ibus_emojier_utf8_entity (const gchar* str);
static void ibus_emojier_update_annotations_with_description (IBusEmojiData* data, const gchar* description);
static void ibus_emojier_set_fixed_size (IBusEmojier* self);
static void ibus_emojier_remove_all_children (IBusEmojier* self);
static void ibus_emojier_show_category_list (IBusEmojier* self);
static IBusEmojierEScrolledWindow* ibus_emojier_escrolled_window_new (GtkAdjustment* hadjustment, GtkAdjustment* vadjustment);
static IBusEmojierEScrolledWindow* ibus_emojier_escrolled_window_construct (GType object_type, GtkAdjustment* hadjustment, GtkAdjustment* vadjustment);
static void ibus_emojier_etitle_label_box_set_lang_label (IBusEmojierETitleLabelBox* self, const gchar* str);
static IBusEmojierEListBox* ibus_emojier_elist_box_new (void);
static IBusEmojierEListBox* ibus_emojier_elist_box_construct (GType object_type);
static void __lambda13_ (IBusEmojier* self, GtkListBox* box, GtkListBoxRow* gtkrow);
static GType ibus_emojier_ebox_row_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void ibus_emojier_show_emoji_for_category (IBusEmojier* self, const gchar* category);
static const gchar* ibus_emojier_ebox_row_get_text (IBusEmojierEBoxRow* self);
static void ___lambda13__gtk_list_box_row_activated (GtkListBox* _sender, GtkListBoxRow* row, gpointer self);
static IBusEmojierEBoxRow* ibus_emojier_ebox_row_new (const gchar* text);
static IBusEmojierEBoxRow* ibus_emojier_ebox_row_construct (GType object_type, const gchar* text);
static GType ibus_emojier_epadded_label_box_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static IBusEmojierEPaddedLabelBox* ibus_emojier_epadded_label_box_new (const gchar* text, GtkAlign align, IBusEmojierTravelDirection direction);
static IBusEmojierEPaddedLabelBox* ibus_emojier_epadded_label_box_construct (GType object_type, const gchar* text, GtkAlign align, IBusEmojierTravelDirection direction);
static gint __lambda14_ (const gchar* a, const gchar* b);
static gint ___lambda14__gcompare_func (gconstpointer a, gconstpointer b);
static void ibus_emojier_show_candidate_panel (IBusEmojier* self);
static void ibus_emojier_show_emoji_variants (IBusEmojier* self, GSList* emojis);
static void ibus_emojier_show_arrow_buttons (IBusEmojier* self);
static void __lambda18_ (IBusEmojier* self);
static void ___lambda18__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda19_ (IBusEmojier* self);
static void ___lambda19__gtk_button_clicked (GtkButton* _sender, gpointer self);
static gboolean ibus_emojier_check_unicode_point (IBusEmojier* self);
static GSList* ibus_emojier_lookup_emojis_from_annotation (IBusEmojier* self, const gchar* annotation);
static void ibus_emojier_show_code_point_description (IBusEmojier* self, const gchar* text);
static gboolean ___lambda12_ (IBusEmojier* self, GtkWidget* w, GdkEventButton* e);
static gboolean ____lambda12__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static GType ibus_emojier_egrid_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static IBusEmojierEGrid* ibus_emojier_egrid_new (void);
static IBusEmojierEGrid* ibus_emojier_egrid_construct (GType object_type);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static IBusEmojierESelectedLabel* ibus_emojier_eselected_label_new (const gchar* text);
static IBusEmojierESelectedLabel* ibus_emojier_eselected_label_construct (GType object_type, const gchar* text);
static GType ibus_emojier_eselected_label_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static IBusEmojierEGoldLabel* ibus_emojier_egold_label_new (const gchar* text);
static IBusEmojierEGoldLabel* ibus_emojier_egold_label_construct (GType object_type, const gchar* text);
static GType ibus_emojier_egold_label_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static IBusEmojierEWhiteLabel* ibus_emojier_ewhite_label_new (const gchar* text);
static IBusEmojierEWhiteLabel* ibus_emojier_ewhite_label_construct (GType object_type, const gchar* text);
static GType ibus_emojier_ewhite_label_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean _____lambda15_ (Block4Data* _data4_, GtkWidget* w, GdkEventButton* e);
static gboolean ______lambda15__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean _____lambda16_ (Block4Data* _data4_, GdkEventMotion* e);
static GdkEventMotion* _vala_GdkEventMotion_copy (GdkEventMotion* self);
static void _vala_GdkEventMotion_free (GdkEventMotion* self);
static gboolean __lambda17_ (IBusEmojier* self);
static gboolean ___lambda17__gsource_func (gpointer self);
static gboolean ______lambda16__gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
static void _vala_array_add8 (GtkLabel** * array, int* length, int* size, GtkLabel* value);
static void ibus_emojier_enter_notify_disable_with_timer (IBusEmojier* self);
static gboolean __lambda24_ (IBusEmojier* self);
static gboolean ___lambda24__gsource_func (gpointer self);
static void ibus_emojier_candidate_panel_cursor_down (IBusEmojier* self);
static void ibus_emojier_candidate_panel_cursor_up (IBusEmojier* self);
static void ibus_emojier_category_list_cursor_move (IBusEmojier* self, guint keyval);
static gboolean ibus_emojier_key_press_cursor_horizontal (IBusEmojier* self, guint keyval, guint modifiers);
static gboolean ibus_emojier_key_press_cursor_vertical (IBusEmojier* self, guint keyval);
static gboolean ibus_emojier_key_press_cursor_home_end (IBusEmojier* self, guint keyval, guint modifiers);
static gboolean ibus_emojier_key_press_escape (IBusEmojier* self);
static gboolean ibus_emojier_key_press_enter (IBusEmojier* self);
static void ibus_emojier_entry_enter_keyval (IBusEmojier* self, guint keyval);
gchar* ibus_emojier_run (IBusEmojier* self, const gchar* input_context_path, GdkEvent* event);
static void _vala_GdkEvent_free (GdkEvent* self);
static void ibus_emojier_real_show (GtkWidget* base);
static gboolean ibus_emojier_real_key_press_event (GtkWidget* base, GdkEventKey* event);
gboolean ibus_emojier_is_running (IBusEmojier* self);
gchar* ibus_emojier_get_input_context_path (IBusEmojier* self);
gchar* ibus_emojier_get_selected_string (IBusEmojier* self);
void ibus_emojier_reset (IBusEmojier* self);
void ibus_emojier_present_centralize (IBusEmojier* self, GdkEvent* event);
gboolean ibus_emojier_has_loaded_emoji_dict (void);
void ibus_emojier_set_annotation_lang (const gchar* lang);
void ibus_emojier_set_emoji_font (const gchar* emoji_font);
static void _vala_PangoFontDescription_free (PangoFontDescription* self);
void ibus_emojier_set_partial_match (gboolean has_partial_match);
void ibus_emojier_set_partial_match_length (gint length);
void ibus_emojier_set_partial_match_condition (gint condition);
void ibus_emojier_set_favorites (gchar** unowned_favorites, int unowned_favorites_length1, gchar** unowned_favorite_annotations, int unowned_favorite_annotations_length1);
static void _vala_array_add9 (gchar** * array, int* length, int* size, gchar* value);
static void _vala_array_add10 (gchar** * array, int* length, int* size, gchar* value);
static void g_cclosure_user_marshal_VOID__UINT_UINT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static gboolean __lambda10_ (IBusEmojierEListBox* self, GdkEventMotion* e);
static gboolean ___lambda10__gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
static gboolean __lambda11_ (IBusEmojierEListBox* self, GdkEventCrossing* e);
static gboolean ___lambda11__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
#define IBUS_EMOJIER_EBOX_ROW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRowPrivate))
static void ibus_emojier_ebox_row_set_text (IBusEmojierEBoxRow* self, const gchar* value);
static void ibus_emojier_ebox_row_finalize (GObject * obj);
static void _vala_ibus_emojier_ebox_row_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_ibus_emojier_ebox_row_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static GType ibus_emojier_epadded_label_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static IBusEmojierEPaddedLabel* ibus_emojier_epadded_label_new (const gchar* text, GtkAlign align);
static IBusEmojierEPaddedLabel* ibus_emojier_epadded_label_construct (GType object_type, const gchar* text, GtkAlign align);
GType icon_widget_get_type (void) G_GNUC_CONST;
IconWidget* icon_widget_new (const gchar* icon_name_or_path, GtkIconSize size);
IconWidget* icon_widget_construct (GType object_type, const gchar* icon_name_or_path, GtkIconSize size);
#define IBUS_EMOJIER_ETITLE_LABEL_BOX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX, IBusEmojierETitleLabelBoxPrivate))
static void ibus_emojier_etitle_label_box_finalize (GObject * obj);
static void ibus_emojier_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const gunichar IBUS_EMOJIER_EMOJI_VARIANT_LIST[6] = {(gunichar) 0x1f3fb, (gunichar) 0x1f3fc, (gunichar) 0x1f3fd, (gunichar) 0x1f3fe, (gunichar) 0x1f3ff, (gunichar) 0x200d};

static GType ibus_emojier_travel_direction_get_type (void) {
	static volatile gsize ibus_emojier_travel_direction_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_travel_direction_type_id__volatile)) {
		static const GEnumValue values[] = {{IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, "IBUS_EMOJIER_TRAVEL_DIRECTION_NONE", "none"}, {IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD, "IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD", "backward"}, {0, NULL, NULL}};
		GType ibus_emojier_travel_direction_type_id;
		ibus_emojier_travel_direction_type_id = g_enum_register_static ("IBusEmojierTravelDirection", values);
		g_once_init_leave (&ibus_emojier_travel_direction_type_id__volatile, ibus_emojier_travel_direction_type_id);
	}
	return ibus_emojier_travel_direction_type_id__volatile;
}


static void _ibus_emojier_check_action_variant_cb_g_simple_action_activate (GSimpleAction* _sender, GVariant* parameter, gpointer self) {
	ibus_emojier_check_action_variant_cb ((IBusEmojier*) self, _sender, parameter);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda20_ (IBusEmojier* self) {
	ibus_emojier_update_candidate_window (self);
}


static void ___lambda20__gtk_editable_changed (GtkEditable* _sender, gpointer self) {
	__lambda20_ ((IBusEmojier*) self);
}


static void __lambda21_ (IBusEmojier* self, GtkEntryIconPosition icon_pos, GdkEvent* event) {
	g_return_if_fail (event != NULL);
	ibus_emojier_hide_candidate_panel (self);
}


static void ___lambda21__gtk_entry_icon_release (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self) {
	__lambda21_ ((IBusEmojier*) self, p0, p1);
}


static void __lambda22_ (IBusEmojier* self) {
	gboolean _tmp0_ = FALSE;
	GMainLoop* _tmp1_;
	_tmp1_ = self->priv->m_loop;
	if (_tmp1_ != NULL) {
		GMainLoop* _tmp2_;
		gboolean _tmp3_;
		_tmp2_ = self->priv->m_loop;
		_tmp3_ = g_main_loop_is_running (_tmp2_);
		_tmp0_ = _tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GMainLoop* _tmp4_;
		_tmp4_ = self->priv->m_loop;
		g_main_loop_quit (_tmp4_);
	}
}


static void ___lambda22__gtk_widget_hide (GtkWidget* _sender, gpointer self) {
	__lambda22_ ((IBusEmojier*) self);
}


static void __lambda23_ (IBusEmojier* self, guint i, guint b, guint s) {
	guint _tmp0_;
	_tmp0_ = i;
	ibus_emojier_candidate_panel_select_index (self, _tmp0_);
}


static void ___lambda23__ibus_emojier_candidate_clicked (IBusEmojier* _sender, guint index, guint button, guint state, gpointer self) {
	__lambda23_ ((IBusEmojier*) self, index, button, state);
}


IBusEmojier* ibus_emojier_construct (GType object_type) {
	IBusEmojier * self = NULL;
	GSimpleAction* action = NULL;
	gboolean _tmp0_;
	GVariant* _tmp1_;
	GVariant* _tmp2_;
	GSimpleAction* _tmp3_;
	GSimpleAction* _tmp4_;
	GSimpleAction* _tmp5_;
	GSimpleAction* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp9_;
	gint _tmp11_;
	gchar** _tmp12_;
	gint _tmp12__length1;
	gchar** _tmp14_;
	gint _tmp14__length1;
	GdkDisplay* display = NULL;
	GdkDisplay* _tmp16_;
	GdkDisplay* _tmp17_;
	GdkScreen* _tmp18_ = NULL;
	GdkDisplay* _tmp19_;
	GdkScreen* screen = NULL;
	GdkScreen* _tmp22_;
	GdkScreen* _tmp23_;
	gchar* backup_locale = NULL;
	const gchar* _tmp24_;
	gchar* _tmp25_;
	const gchar* _tmp26_;
	ThemedRGBA* _tmp29_;
	guint bg_red = 0U;
	ThemedRGBA* _tmp30_;
	GdkRGBA* _tmp31_;
	GdkRGBA* _tmp32_;
	gdouble _tmp33_;
	guint bg_green = 0U;
	ThemedRGBA* _tmp34_;
	GdkRGBA* _tmp35_;
	GdkRGBA* _tmp36_;
	gdouble _tmp37_;
	guint bg_blue = 0U;
	ThemedRGBA* _tmp38_;
	GdkRGBA* _tmp39_;
	GdkRGBA* _tmp40_;
	gdouble _tmp41_;
	gdouble bg_alpha = 0.0;
	ThemedRGBA* _tmp42_;
	GdkRGBA* _tmp43_;
	GdkRGBA* _tmp44_;
	gdouble _tmp45_;
	gchar* data = NULL;
	guint _tmp46_;
	guint _tmp47_;
	guint _tmp48_;
	gdouble _tmp49_;
	gchar* _tmp50_;
	gchar* _tmp51_;
	gchar* _tmp52_;
	gchar* _tmp53_;
	const gchar* _tmp54_;
	gint _tmp55_;
	gchar* _tmp56_;
	gchar* _tmp57_;
	gchar* _tmp58_;
	gchar* _tmp59_;
	gchar* _tmp60_;
	gchar* _tmp61_;
	guint fg_red = 0U;
	ThemedRGBA* _tmp62_;
	GdkRGBA* _tmp63_;
	GdkRGBA* _tmp64_;
	gdouble _tmp65_;
	guint fg_green = 0U;
	ThemedRGBA* _tmp66_;
	GdkRGBA* _tmp67_;
	GdkRGBA* _tmp68_;
	gdouble _tmp69_;
	guint fg_blue = 0U;
	ThemedRGBA* _tmp70_;
	GdkRGBA* _tmp71_;
	GdkRGBA* _tmp72_;
	gdouble _tmp73_;
	gdouble fg_alpha = 0.0;
	ThemedRGBA* _tmp74_;
	GdkRGBA* _tmp75_;
	GdkRGBA* _tmp76_;
	gdouble _tmp77_;
	ThemedRGBA* _tmp78_;
	GdkRGBA* _tmp79_;
	GdkRGBA* _tmp80_;
	gdouble _tmp81_;
	ThemedRGBA* _tmp82_;
	GdkRGBA* _tmp83_;
	GdkRGBA* _tmp84_;
	gdouble _tmp85_;
	ThemedRGBA* _tmp86_;
	GdkRGBA* _tmp87_;
	GdkRGBA* _tmp88_;
	gdouble _tmp89_;
	ThemedRGBA* _tmp90_;
	GdkRGBA* _tmp91_;
	GdkRGBA* _tmp92_;
	gdouble _tmp93_;
	const gchar* _tmp94_;
	guint _tmp95_;
	guint _tmp96_;
	guint _tmp97_;
	gdouble _tmp98_;
	gchar* _tmp99_;
	gchar* _tmp100_;
	gchar* _tmp101_;
	gchar* _tmp102_;
	const gchar* _tmp103_;
	gint _tmp104_;
	gchar* _tmp105_;
	gchar* _tmp106_;
	gchar* _tmp107_;
	gchar* _tmp108_;
	gchar* _tmp109_;
	gchar* _tmp110_;
	guint _tmp111_;
	guint _tmp112_;
	guint _tmp113_;
	gdouble _tmp114_;
	gchar* _tmp115_;
	gchar* _tmp116_;
	gchar* _tmp117_;
	gchar* _tmp118_;
	gchar* _tmp119_;
	gchar* _tmp120_;
	gchar* _tmp121_;
	const gchar* _tmp122_;
	guint _tmp123_;
	guint _tmp124_;
	guint _tmp125_;
	gdouble _tmp126_;
	gchar* _tmp127_;
	gchar* _tmp128_;
	gchar* _tmp129_;
	gchar* _tmp130_;
	const gchar* _tmp131_;
	gint _tmp132_;
	gchar* _tmp133_;
	gchar* _tmp134_;
	gchar* _tmp135_;
	gchar* _tmp136_;
	gchar* _tmp137_;
	gchar* _tmp138_;
	gchar* _tmp139_;
	gchar* _tmp140_;
	gchar* _tmp141_;
	GtkCssProvider* css_provider = NULL;
	GtkCssProvider* _tmp142_;
	const gchar* _tmp147_;
	GdkScreen* _tmp149_;
	GtkCssProvider* _tmp150_;
	IBusEmojierETitleLabelBox* _tmp151_;
	IBusEmojierETitleLabelBox* _tmp152_;
	GtkBox* _tmp153_;
	GtkBox* _tmp154_;
	IBusEmojierEEntry* _tmp155_;
	IBusEmojierEEntry* _tmp156_;
	GtkBox* _tmp157_;
	IBusEmojierEEntry* _tmp158_;
	IBusEmojierEEntry* _tmp159_;
	IBusEmojierEEntry* _tmp160_;
	AtkObject* obj = NULL;
	IBusEmojierEEntry* _tmp161_;
	AtkObject* _tmp162_;
	AtkObject* _tmp163_;
	AtkObject* _tmp164_;
	IBusLookupTable* _tmp165_;
	IBusLookupTable* _tmp166_;
	GHashTable* _tmp167_;
	GError * _inner_error_ = NULL;
	self = (IBusEmojier*) g_object_new (object_type, "type", GTK_WINDOW_TOPLEVEL, "events", ((GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK) | GDK_BUTTON_PRESS_MASK) | GDK_BUTTON_RELEASE_MASK, "window-position", GTK_WIN_POS_CENTER, "icon-name", "ibus-setup", "accept-focus", TRUE, "resizable", TRUE, "focus-visible", TRUE, NULL);
	_tmp0_ = ibus_emojier_m_show_emoji_variant;
	_tmp1_ = g_variant_new_boolean (_tmp0_);
	g_variant_ref_sink (_tmp1_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_simple_action_new_stateful ("variant", NULL, _tmp2_);
	_tmp4_ = _tmp3_;
	_g_variant_unref0 (_tmp2_);
	action = _tmp4_;
	_tmp5_ = action;
	g_signal_connect_object (_tmp5_, "activate", (GCallback) _ibus_emojier_check_action_variant_cb_g_simple_action_activate, self, 0);
	_tmp6_ = action;
	g_action_map_add_action ((GActionMap*) self, (GAction*) _tmp6_);
	_tmp7_ = ibus_emojier_m_current_lang_id;
	if (_tmp7_ == NULL) {
		gchar* _tmp8_;
		_tmp8_ = g_strdup ("en");
		_g_free0 (ibus_emojier_m_current_lang_id);
		ibus_emojier_m_current_lang_id = _tmp8_;
	}
	_tmp9_ = ibus_emojier_m_emoji_font_family;
	if (_tmp9_ == NULL) {
		gchar* _tmp10_;
		_tmp10_ = g_strdup ("Monospace");
		_g_free0 (ibus_emojier_m_emoji_font_family);
		ibus_emojier_m_emoji_font_family = _tmp10_;
	}
	_tmp11_ = ibus_emojier_m_emoji_font_size;
	if (_tmp11_ == 0) {
		ibus_emojier_m_emoji_font_size = 16;
	}
	_tmp12_ = ibus_emojier_m_favorites;
	_tmp12__length1 = ibus_emojier_m_favorites_length1;
	if (_tmp12_ == NULL) {
		gchar** _tmp13_;
		_tmp13_ = g_new0 (gchar*, 0 + 1);
		ibus_emojier_m_favorites = (_vala_array_free (ibus_emojier_m_favorites, ibus_emojier_m_favorites_length1, (GDestroyNotify) g_free), NULL);
		ibus_emojier_m_favorites = _tmp13_;
		ibus_emojier_m_favorites_length1 = 0;
		_ibus_emojier_m_favorites_size_ = ibus_emojier_m_favorites_length1;
	}
	_tmp14_ = ibus_emojier_m_favorite_annotations;
	_tmp14__length1 = ibus_emojier_m_favorite_annotations_length1;
	if (_tmp14_ == NULL) {
		gchar** _tmp15_;
		_tmp15_ = g_new0 (gchar*, 0 + 1);
		ibus_emojier_m_favorite_annotations = (_vala_array_free (ibus_emojier_m_favorite_annotations, ibus_emojier_m_favorite_annotations_length1, (GDestroyNotify) g_free), NULL);
		ibus_emojier_m_favorite_annotations = _tmp15_;
		ibus_emojier_m_favorite_annotations_length1 = 0;
		_ibus_emojier_m_favorite_annotations_size_ = ibus_emojier_m_favorite_annotations_length1;
	}
	_tmp16_ = gdk_display_get_default ();
	_tmp17_ = _g_object_ref0 (_tmp16_);
	display = _tmp17_;
	_tmp19_ = display;
	if (_tmp19_ != NULL) {
		GdkDisplay* _tmp20_;
		GdkScreen* _tmp21_;
		_tmp20_ = display;
		_tmp21_ = gdk_display_get_default_screen (_tmp20_);
		_tmp18_ = _tmp21_;
	} else {
		_tmp18_ = NULL;
	}
	_tmp22_ = _g_object_ref0 (_tmp18_);
	screen = _tmp22_;
	_tmp23_ = screen;
	if (_tmp23_ == NULL) {
		g_warning ("emojier.vala:297: Could not open display.");
		_g_object_unref0 (screen);
		_g_object_unref0 (display);
		_g_object_unref0 (action);
		return self;
	}
	_tmp24_ = setlocale (LC_NUMERIC, NULL);
	_tmp25_ = g_strdup (_tmp24_);
	backup_locale = _tmp25_;
	_tmp26_ = setlocale (LC_NUMERIC, "en_US.UTF-8");
	if (_tmp26_ == NULL) {
		const gchar* _tmp27_;
		_tmp27_ = setlocale (LC_NUMERIC, "C.UTF-8");
		if (_tmp27_ == NULL) {
			const gchar* _tmp28_;
			_tmp28_ = setlocale (LC_NUMERIC, "C");
			if (_tmp28_ == NULL) {
				g_warning ("emojier.vala:306: %s", "You don't install either en_US.UTF-8 or C.UTF-8 " "or C locale");
			}
		}
	}
	_tmp29_ = themed_rgba_new ((GtkWidget*) self);
	_themed_rgba_unref0 (self->priv->m_rgba);
	self->priv->m_rgba = _tmp29_;
	_tmp30_ = self->priv->m_rgba;
	_tmp31_ = themed_rgba_get_normal_bg (_tmp30_);
	_tmp32_ = _tmp31_;
	_tmp33_ = (*_tmp32_).red;
	bg_red = (guint) (_tmp33_ * 255);
	_tmp34_ = self->priv->m_rgba;
	_tmp35_ = themed_rgba_get_normal_bg (_tmp34_);
	_tmp36_ = _tmp35_;
	_tmp37_ = (*_tmp36_).green;
	bg_green = (guint) (_tmp37_ * 255);
	_tmp38_ = self->priv->m_rgba;
	_tmp39_ = themed_rgba_get_normal_bg (_tmp38_);
	_tmp40_ = _tmp39_;
	_tmp41_ = (*_tmp40_).blue;
	bg_blue = (guint) (_tmp41_ * 255);
	_tmp42_ = self->priv->m_rgba;
	_tmp43_ = themed_rgba_get_normal_bg (_tmp42_);
	_tmp44_ = _tmp43_;
	_tmp45_ = (*_tmp44_).alpha;
	bg_alpha = _tmp45_;
	_tmp46_ = bg_red;
	_tmp47_ = bg_green;
	_tmp48_ = bg_blue;
	_tmp49_ = bg_alpha;
	_tmp50_ = g_strdup_printf ("rgba(%u, %u, %u, %lf); ", _tmp46_, _tmp47_, _tmp48_, _tmp49_);
	_tmp51_ = _tmp50_;
	_tmp52_ = g_strconcat ("#IBusEmojierWhiteLabel { background-color: ", _tmp51_, NULL);
	_tmp53_ = _tmp52_;
	_tmp54_ = ibus_emojier_m_emoji_font_family;
	_tmp55_ = ibus_emojier_m_emoji_font_size;
	_tmp56_ = g_strdup_printf ("font-family: %s; font-size: %dpt; ", _tmp54_, _tmp55_);
	_tmp57_ = _tmp56_;
	_tmp58_ = g_strconcat (_tmp53_, _tmp57_, NULL);
	_tmp59_ = _tmp58_;
	_tmp60_ = g_strconcat (_tmp59_, "border-width: 4px; border-radius: 3px; } ", NULL);
	_tmp61_ = _tmp60_;
	_g_free0 (_tmp59_);
	_g_free0 (_tmp57_);
	_g_free0 (_tmp53_);
	_g_free0 (_tmp51_);
	data = _tmp61_;
	_tmp62_ = self->priv->m_rgba;
	_tmp63_ = themed_rgba_get_selected_fg (_tmp62_);
	_tmp64_ = _tmp63_;
	_tmp65_ = (*_tmp64_).red;
	fg_red = (guint) (_tmp65_ * 255);
	_tmp66_ = self->priv->m_rgba;
	_tmp67_ = themed_rgba_get_selected_fg (_tmp66_);
	_tmp68_ = _tmp67_;
	_tmp69_ = (*_tmp68_).green;
	fg_green = (guint) (_tmp69_ * 255);
	_tmp70_ = self->priv->m_rgba;
	_tmp71_ = themed_rgba_get_selected_fg (_tmp70_);
	_tmp72_ = _tmp71_;
	_tmp73_ = (*_tmp72_).blue;
	fg_blue = (guint) (_tmp73_ * 255);
	_tmp74_ = self->priv->m_rgba;
	_tmp75_ = themed_rgba_get_selected_fg (_tmp74_);
	_tmp76_ = _tmp75_;
	_tmp77_ = (*_tmp76_).alpha;
	fg_alpha = _tmp77_;
	_tmp78_ = self->priv->m_rgba;
	_tmp79_ = themed_rgba_get_selected_bg (_tmp78_);
	_tmp80_ = _tmp79_;
	_tmp81_ = (*_tmp80_).red;
	bg_red = (guint) (_tmp81_ * 255);
	_tmp82_ = self->priv->m_rgba;
	_tmp83_ = themed_rgba_get_selected_bg (_tmp82_);
	_tmp84_ = _tmp83_;
	_tmp85_ = (*_tmp84_).green;
	bg_green = (guint) (_tmp85_ * 255);
	_tmp86_ = self->priv->m_rgba;
	_tmp87_ = themed_rgba_get_selected_bg (_tmp86_);
	_tmp88_ = _tmp87_;
	_tmp89_ = (*_tmp88_).blue;
	bg_blue = (guint) (_tmp89_ * 255);
	_tmp90_ = self->priv->m_rgba;
	_tmp91_ = themed_rgba_get_selected_bg (_tmp90_);
	_tmp92_ = _tmp91_;
	_tmp93_ = (*_tmp92_).alpha;
	bg_alpha = _tmp93_;
	_tmp94_ = data;
	_tmp95_ = fg_red;
	_tmp96_ = fg_green;
	_tmp97_ = fg_blue;
	_tmp98_ = fg_alpha;
	_tmp99_ = g_strdup_printf ("rgba(%u, %u, %u, %lf); ", _tmp95_, _tmp96_, _tmp97_, _tmp98_);
	_tmp100_ = _tmp99_;
	_tmp101_ = g_strconcat ("#IBusEmojierSelectedLabel { color: ", _tmp100_, NULL);
	_tmp102_ = _tmp101_;
	_tmp103_ = ibus_emojier_m_emoji_font_family;
	_tmp104_ = ibus_emojier_m_emoji_font_size;
	_tmp105_ = g_strdup_printf ("font-family: %s; font-size: %dpt; ", _tmp103_, _tmp104_);
	_tmp106_ = _tmp105_;
	_tmp107_ = g_strconcat (_tmp102_, _tmp106_, NULL);
	_tmp108_ = _tmp107_;
	_tmp109_ = g_strconcat (_tmp108_, "background-color: ", NULL);
	_tmp110_ = _tmp109_;
	_tmp111_ = bg_red;
	_tmp112_ = bg_green;
	_tmp113_ = bg_blue;
	_tmp114_ = bg_alpha;
	_tmp115_ = g_strdup_printf ("rgba(%u, %u, %u, %lf); ", _tmp111_, _tmp112_, _tmp113_, _tmp114_);
	_tmp116_ = _tmp115_;
	_tmp117_ = g_strconcat (_tmp110_, _tmp116_, NULL);
	_tmp118_ = _tmp117_;
	_tmp119_ = g_strconcat (_tmp118_, "border-width: 4px; border-radius: 3px; }", NULL);
	_tmp120_ = _tmp119_;
	_tmp121_ = g_strconcat (_tmp94_, _tmp120_, NULL);
	_g_free0 (data);
	data = _tmp121_;
	_g_free0 (_tmp120_);
	_g_free0 (_tmp118_);
	_g_free0 (_tmp116_);
	_g_free0 (_tmp110_);
	_g_free0 (_tmp108_);
	_g_free0 (_tmp106_);
	_g_free0 (_tmp102_);
	_g_free0 (_tmp100_);
	_tmp122_ = data;
	_tmp123_ = fg_red;
	_tmp124_ = fg_green;
	_tmp125_ = fg_blue;
	_tmp126_ = fg_alpha;
	_tmp127_ = g_strdup_printf ("rgba(%u, %u, %u, %lf); ", _tmp123_, _tmp124_, _tmp125_, _tmp126_);
	_tmp128_ = _tmp127_;
	_tmp129_ = g_strconcat ("#IBusEmojierGoldLabel { color: ", _tmp128_, NULL);
	_tmp130_ = _tmp129_;
	_tmp131_ = ibus_emojier_m_emoji_font_family;
	_tmp132_ = ibus_emojier_m_emoji_font_size;
	_tmp133_ = g_strdup_printf ("font-family: %s; font-size: %dpt; ", _tmp131_, _tmp132_);
	_tmp134_ = _tmp133_;
	_tmp135_ = g_strconcat (_tmp130_, _tmp134_, NULL);
	_tmp136_ = _tmp135_;
	_tmp137_ = g_strconcat (_tmp136_, "background-color: #b09c5f; ", NULL);
	_tmp138_ = _tmp137_;
	_tmp139_ = g_strconcat (_tmp138_, "border-width: 4px; border-radius: 3px; }", NULL);
	_tmp140_ = _tmp139_;
	_tmp141_ = g_strconcat (_tmp122_, _tmp140_, NULL);
	_g_free0 (data);
	data = _tmp141_;
	_g_free0 (_tmp140_);
	_g_free0 (_tmp138_);
	_g_free0 (_tmp136_);
	_g_free0 (_tmp134_);
	_g_free0 (_tmp130_);
	_g_free0 (_tmp128_);
	_tmp142_ = gtk_css_provider_new ();
	css_provider = _tmp142_;
	{
		GtkCssProvider* _tmp143_;
		const gchar* _tmp144_;
		_tmp143_ = css_provider;
		_tmp144_ = data;
		gtk_css_provider_load_from_data (_tmp143_, _tmp144_, (gssize) -1, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp145_;
		const gchar* _tmp146_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp145_ = e;
		_tmp146_ = _tmp145_->message;
		g_warning ("emojier.vala:353: Failed css_provider_from_data: %s", _tmp146_);
		_g_error_free0 (e);
		_g_object_unref0 (css_provider);
		_g_free0 (data);
		_g_free0 (backup_locale);
		_g_object_unref0 (screen);
		_g_object_unref0 (display);
		_g_object_unref0 (action);
		return self;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (css_provider);
		_g_free0 (data);
		_g_free0 (backup_locale);
		_g_object_unref0 (screen);
		_g_object_unref0 (display);
		_g_object_unref0 (action);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp147_ = backup_locale;
	if (_tmp147_ != NULL) {
		const gchar* _tmp148_;
		_tmp148_ = backup_locale;
		setlocale (LC_NUMERIC, _tmp148_);
	} else {
		setlocale (LC_NUMERIC, "");
	}
	_tmp149_ = screen;
	_tmp150_ = css_provider;
	gtk_style_context_add_provider_for_screen (_tmp149_, (GtkStyleProvider*) _tmp150_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	_tmp151_ = ibus_emojier_etitle_label_box_new (_ ("Emoji Choice"));
	g_object_ref_sink (_tmp151_);
	_g_object_unref0 (self->priv->m_title);
	self->priv->m_title = _tmp151_;
	_tmp152_ = self->priv->m_title;
	gtk_window_set_titlebar ((GtkWindow*) self, (GtkWidget*) _tmp152_);
	_tmp153_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp153_);
	_g_object_unref0 (self->priv->m_vbox);
	self->priv->m_vbox = _tmp153_;
	_tmp154_ = self->priv->m_vbox;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp154_);
	_tmp155_ = ibus_emojier_eentry_new ();
	g_object_ref_sink (_tmp155_);
	_g_object_unref0 (self->priv->m_entry);
	self->priv->m_entry = _tmp155_;
	_tmp156_ = self->priv->m_entry;
	gtk_entry_set_placeholder_text ((GtkEntry*) _tmp156_, _ ("Type annotation or choose emoji"));
	_tmp157_ = self->priv->m_vbox;
	_tmp158_ = self->priv->m_entry;
	gtk_container_add ((GtkContainer*) _tmp157_, (GtkWidget*) _tmp158_);
	_tmp159_ = self->priv->m_entry;
	g_signal_connect_object ((GtkEditable*) _tmp159_, "changed", (GCallback) ___lambda20__gtk_editable_changed, self, 0);
	_tmp160_ = self->priv->m_entry;
	g_signal_connect_object ((GtkEntry*) _tmp160_, "icon-release", (GCallback) ___lambda21__gtk_entry_icon_release, self, 0);
	_tmp161_ = self->priv->m_entry;
	_tmp162_ = gtk_widget_get_accessible ((GtkWidget*) _tmp161_);
	_tmp163_ = _g_object_ref0 (_tmp162_);
	obj = _tmp163_;
	_tmp164_ = obj;
	atk_object_set_role (_tmp164_, ATK_ROLE_STATUSBAR);
	_tmp165_ = ibus_lookup_table_new ((guint) 1, (guint) 0, TRUE, TRUE);
	g_object_ref_sink (_tmp165_);
	_g_object_unref0 (self->priv->m_lookup_table);
	self->priv->m_lookup_table = _tmp165_;
	_tmp166_ = self->priv->m_lookup_table;
	ibus_lookup_table_set_page_size (_tmp166_, IBUS_EMOJIER_EMOJI_GRID_PAGE * IBUS_EMOJIER_EMOJI_GRID_PAGE);
	g_signal_connect_object ((GtkWidget*) self, "hide", (GCallback) ___lambda22__gtk_widget_hide, self, 0);
	g_signal_connect_object (self, "candidate-clicked", (GCallback) ___lambda23__ibus_emojier_candidate_clicked, self, 0);
	_tmp167_ = ibus_emojier_m_annotation_to_emojis_dict;
	if (_tmp167_ == NULL) {
		ibus_emojier_reload_emoji_dict ();
	}
	_g_object_unref0 (obj);
	_g_object_unref0 (css_provider);
	_g_free0 (data);
	_g_free0 (backup_locale);
	_g_object_unref0 (screen);
	_g_object_unref0 (display);
	_g_object_unref0 (action);
	return self;
}


IBusEmojier* ibus_emojier_new (void) {
	return ibus_emojier_construct (TYPE_IBUS_EMOJIER);
}


static void ibus_emojier_reload_emoji_dict (void) {
	const gchar* _tmp0_;
	ibus_emojier_init_emoji_dict ();
	ibus_emojier_make_emoji_dict ("en");
	_tmp0_ = ibus_emojier_m_current_lang_id;
	if (g_strcmp0 (_tmp0_, "en") != 0) {
		gchar** lang_ids = NULL;
		const gchar* _tmp1_;
		gchar** _tmp2_;
		gchar** _tmp3_;
		gint lang_ids_length1;
		gint _lang_ids_size_;
		gchar** _tmp4_;
		gint _tmp4__length1;
		const gchar* _tmp9_;
		_tmp1_ = ibus_emojier_m_current_lang_id;
		_tmp3_ = _tmp2_ = g_strsplit (_tmp1_, "_", 0);
		lang_ids = _tmp3_;
		lang_ids_length1 = _vala_array_length (_tmp2_);
		_lang_ids_size_ = lang_ids_length1;
		_tmp4_ = lang_ids;
		_tmp4__length1 = lang_ids_length1;
		if (_tmp4__length1 > 1) {
			gchar* sub_id = NULL;
			gchar** _tmp5_;
			gint _tmp5__length1;
			const gchar* _tmp6_;
			gchar* _tmp7_;
			const gchar* _tmp8_;
			_tmp5_ = lang_ids;
			_tmp5__length1 = lang_ids_length1;
			_tmp6_ = _tmp5_[0];
			_tmp7_ = g_strdup (_tmp6_);
			sub_id = _tmp7_;
			_tmp8_ = sub_id;
			ibus_emojier_make_emoji_dict (_tmp8_);
			_g_free0 (sub_id);
		}
		_tmp9_ = ibus_emojier_m_current_lang_id;
		ibus_emojier_make_emoji_dict (_tmp9_);
		lang_ids = (_vala_array_free (lang_ids, lang_ids_length1, (GDestroyNotify) g_free), NULL);
	}
	ibus_emojier_update_favorite_emoji_dict ();
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static inline void _g_slist_free__g_free0_ (GSList* self) {
	g_slist_free_full (self, (GDestroyNotify) _g_free0_);
}


static void __g_slist_free__g_free0_0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (_g_slist_free__g_free0_ (var), NULL));
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void ibus_emojier_init_emoji_dict (void) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashFunc _tmp3_;
	GEqualFunc _tmp4_;
	GHashTable* _tmp5_;
	GHashFunc _tmp6_;
	GEqualFunc _tmp7_;
	GHashTable* _tmp8_;
	GHashFunc _tmp9_;
	GEqualFunc _tmp10_;
	GHashTable* _tmp11_;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, __g_slist_free__g_free0_0_);
	_g_hash_table_unref0 (ibus_emojier_m_annotation_to_emojis_dict);
	ibus_emojier_m_annotation_to_emojis_dict = _tmp2_;
	_tmp3_ = g_str_hash;
	_tmp4_ = g_str_equal;
	_tmp5_ = g_hash_table_new_full (_tmp3_, _tmp4_, _g_free0_, _g_object_unref0_);
	_g_hash_table_unref0 (ibus_emojier_m_emoji_to_data_dict);
	ibus_emojier_m_emoji_to_data_dict = _tmp5_;
	_tmp6_ = g_str_hash;
	_tmp7_ = g_str_equal;
	_tmp8_ = g_hash_table_new_full (_tmp6_, _tmp7_, _g_free0_, __g_slist_free__g_free0_0_);
	_g_hash_table_unref0 (ibus_emojier_m_category_to_emojis_dict);
	ibus_emojier_m_category_to_emojis_dict = _tmp8_;
	_tmp9_ = g_str_hash;
	_tmp10_ = g_str_equal;
	_tmp11_ = g_hash_table_new_full (_tmp9_, _tmp10_, _g_free0_, __g_slist_free__g_free0_0_);
	_g_hash_table_unref0 (ibus_emojier_m_emoji_to_emoji_variants_dict);
	ibus_emojier_m_emoji_to_emoji_variants_dict = _tmp11_;
}


static inline void _g_slist_free__g_object_unref0_ (GSList* self) {
	g_slist_free_full (self, (GDestroyNotify) _g_object_unref0_);
}


static void ibus_emojier_make_emoji_dict (const gchar* lang) {
	GSList* emoji_list = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	GSList* _tmp5_;
	GSList* _tmp6_;
	GSList* _tmp7_;
	GSList* _tmp8_;
	GList* annotations = NULL;
	GHashTable* _tmp15_;
	GList* _tmp16_;
	GList* _tmp17_;
	g_return_if_fail (lang != NULL);
	_tmp0_ = lang;
	_tmp1_ = g_strconcat (PKGDATADIR "/dicts/emoji-", _tmp0_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat (_tmp2_, ".dict", NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = ibus_emoji_data_load (_tmp4_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	emoji_list = _tmp6_;
	_tmp7_ = emoji_list;
	if (_tmp7_ == NULL) {
		__g_slist_free__g_object_unref0_0 (emoji_list);
		return;
	}
	_tmp8_ = emoji_list;
	{
		GSList* data_collection = NULL;
		GSList* data_it = NULL;
		data_collection = _tmp8_;
		for (data_it = data_collection; data_it != NULL; data_it = data_it->next) {
			IBusEmojiData* _tmp9_;
			IBusEmojiData* data = NULL;
			_tmp9_ = _g_object_ref0 ((IBusEmojiData*) data_it->data);
			data = _tmp9_;
			{
				IBusEmojiData* _tmp10_;
				const gchar* _tmp11_;
				IBusEmojiData* _tmp12_;
				IBusEmojiData* _tmp13_;
				const gchar* _tmp14_;
				_tmp10_ = data;
				_tmp11_ = lang;
				ibus_emojier_update_emoji_to_data_dict (_tmp10_, _tmp11_);
				_tmp12_ = data;
				ibus_emojier_update_annotation_to_emojis_dict (_tmp12_);
				_tmp13_ = data;
				_tmp14_ = lang;
				ibus_emojier_update_category_to_emojis_dict (_tmp13_, _tmp14_);
				_g_object_unref0 (data);
			}
		}
	}
	_tmp15_ = ibus_emojier_m_annotation_to_emojis_dict;
	_tmp16_ = g_hash_table_get_keys (_tmp15_);
	annotations = _tmp16_;
	_tmp17_ = annotations;
	{
		GList* annotation_collection = NULL;
		GList* annotation_it = NULL;
		annotation_collection = _tmp17_;
		for (annotation_it = annotation_collection; annotation_it != NULL; annotation_it = annotation_it->next) {
			const gchar* annotation = NULL;
			annotation = (const gchar*) annotation_it->data;
			{
				gint _tmp18_;
				const gchar* _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				_tmp18_ = ibus_emojier_m_emoji_max_seq_len;
				_tmp19_ = annotation;
				_tmp20_ = strlen (_tmp19_);
				_tmp21_ = _tmp20_;
				if (_tmp18_ < _tmp21_) {
					const gchar* _tmp22_;
					gint _tmp23_;
					gint _tmp24_;
					_tmp22_ = annotation;
					_tmp23_ = strlen (_tmp22_);
					_tmp24_ = _tmp23_;
					ibus_emojier_m_emoji_max_seq_len = _tmp24_;
				}
			}
		}
	}
	_g_list_free0 (annotations);
	__g_slist_free__g_object_unref0_0 (emoji_list);
}


static gpointer _g_strdup_gcopy_func (gconstpointer src, gpointer self) {
	gpointer result;
	result = g_strdup ((const gchar*) src);
	return result;
}


static void ibus_emojier_update_annotation_to_emojis_dict (IBusEmojiData* data) {
	gchar* emoji = NULL;
	IBusEmojiData* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	GSList* annotations = NULL;
	IBusEmojiData* _tmp3_;
	GSList* _tmp4_;
	GSList* _tmp5_;
	g_return_if_fail (data != NULL);
	_tmp0_ = data;
	_tmp1_ = ibus_emoji_data_get_emoji (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	emoji = _tmp2_;
	_tmp3_ = data;
	_tmp4_ = ibus_emoji_data_get_annotations (_tmp3_);
	annotations = _tmp4_;
	_tmp5_ = annotations;
	{
		GSList* annotation_collection = NULL;
		GSList* annotation_it = NULL;
		annotation_collection = _tmp5_;
		for (annotation_it = annotation_collection; annotation_it != NULL; annotation_it = annotation_it->next) {
			gchar* _tmp6_;
			gchar* annotation = NULL;
			_tmp6_ = g_strdup ((const gchar*) annotation_it->data);
			annotation = _tmp6_;
			{
				gboolean has_emoji = FALSE;
				GSList* hits = NULL;
				GHashTable* _tmp7_;
				const gchar* _tmp8_;
				gconstpointer _tmp9_;
				GSList* _tmp10_;
				GSList* _tmp11_;
				gboolean _tmp15_;
				has_emoji = FALSE;
				_tmp7_ = ibus_emojier_m_annotation_to_emojis_dict;
				_tmp8_ = annotation;
				_tmp9_ = g_hash_table_lookup (_tmp7_, _tmp8_);
				_tmp10_ = g_slist_copy_deep ((GSList*) _tmp9_, _g_strdup_gcopy_func, NULL);
				hits = _tmp10_;
				_tmp11_ = hits;
				{
					GSList* hit_emoji_collection = NULL;
					GSList* hit_emoji_it = NULL;
					hit_emoji_collection = _tmp11_;
					for (hit_emoji_it = hit_emoji_collection; hit_emoji_it != NULL; hit_emoji_it = hit_emoji_it->next) {
						gchar* _tmp12_;
						gchar* hit_emoji = NULL;
						_tmp12_ = g_strdup ((const gchar*) hit_emoji_it->data);
						hit_emoji = _tmp12_;
						{
							const gchar* _tmp13_;
							const gchar* _tmp14_;
							_tmp13_ = hit_emoji;
							_tmp14_ = emoji;
							if (g_strcmp0 (_tmp13_, _tmp14_) == 0) {
								has_emoji = TRUE;
								_g_free0 (hit_emoji);
								break;
							}
							_g_free0 (hit_emoji);
						}
					}
				}
				_tmp15_ = has_emoji;
				if (!_tmp15_) {
					const gchar* _tmp16_;
					gchar* _tmp17_;
					GHashTable* _tmp18_;
					const gchar* _tmp19_;
					gchar* _tmp20_;
					GSList* _tmp21_;
					GSList* _tmp22_;
					_tmp16_ = emoji;
					_tmp17_ = g_strdup (_tmp16_);
					hits = g_slist_append (hits, _tmp17_);
					_tmp18_ = ibus_emojier_m_annotation_to_emojis_dict;
					_tmp19_ = annotation;
					_tmp20_ = g_strdup (_tmp19_);
					_tmp21_ = hits;
					_tmp22_ = g_slist_copy_deep (_tmp21_, _g_strdup_gcopy_func, NULL);
					g_hash_table_replace (_tmp18_, _tmp20_, _tmp22_);
				}
				__g_slist_free__g_free0_0 (hits);
				_g_free0 (annotation);
			}
		}
	}
	_g_free0 (emoji);
}


static gunichar string_get_char (const gchar* self, glong index) {
	gunichar result = 0U;
	glong _tmp0_;
	gunichar _tmp1_;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	result = _tmp1_;
	return result;
}


static gchar* ibus_emojier_utf8_code_point (const gchar* str) {
	gchar* result = NULL;
	GString* buff = NULL;
	GString* _tmp0_;
	gint length = 0;
	const gchar* _tmp1_;
	gint _tmp2_;
	GString* _tmp20_;
	const gchar* _tmp21_;
	gchar* _tmp22_;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = g_string_new ("");
	buff = _tmp0_;
	_tmp1_ = str;
	_tmp2_ = g_utf8_strlen (_tmp1_, (gssize) -1);
	length = _tmp2_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_;
				gint _tmp6_;
				gunichar ch = 0U;
				const gchar* _tmp7_;
				gunichar _tmp8_;
				gint _tmp9_;
				const gchar* _tmp18_;
				const gchar* _tmp19_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = length;
				if (!(_tmp5_ < _tmp6_)) {
					break;
				}
				_tmp7_ = str;
				_tmp8_ = string_get_char (_tmp7_, (glong) 0);
				ch = _tmp8_;
				_tmp9_ = i;
				if (_tmp9_ == 0) {
					GString* _tmp10_;
					gunichar _tmp11_;
					gchar* _tmp12_;
					gchar* _tmp13_;
					_tmp10_ = buff;
					_tmp11_ = ch;
					_tmp12_ = g_strdup_printf ("U+%04X", (guint) _tmp11_);
					_tmp13_ = _tmp12_;
					g_string_append (_tmp10_, _tmp13_);
					_g_free0 (_tmp13_);
				} else {
					GString* _tmp14_;
					gunichar _tmp15_;
					gchar* _tmp16_;
					gchar* _tmp17_;
					_tmp14_ = buff;
					_tmp15_ = ch;
					_tmp16_ = g_strdup_printf (" %04X", (guint) _tmp15_);
					_tmp17_ = _tmp16_;
					g_string_append (_tmp14_, _tmp17_);
					_g_free0 (_tmp17_);
				}
				_tmp18_ = str;
				_tmp19_ = g_utf8_next_char (_tmp18_);
				str = _tmp19_;
			}
		}
	}
	_tmp20_ = buff;
	_tmp21_ = _tmp20_->str;
	_tmp22_ = g_strdup (_tmp21_);
	result = _tmp22_;
	_g_string_free0 (buff);
	return result;
}


static gchar* ibus_emojier_utf8_entity (const gchar* str) {
	gchar* result = NULL;
	GString* buff = NULL;
	GString* _tmp0_;
	gint length = 0;
	const gchar* _tmp1_;
	gint _tmp2_;
	GString* _tmp17_;
	const gchar* _tmp18_;
	gchar* _tmp19_;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = g_string_new ("");
	buff = _tmp0_;
	_tmp1_ = str;
	_tmp2_ = g_utf8_strlen (_tmp1_, (gssize) -1);
	length = _tmp2_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_;
				gint _tmp6_;
				gunichar ch = 0U;
				const gchar* _tmp7_;
				gunichar _tmp8_;
				gunichar _tmp9_;
				const gchar* _tmp15_;
				const gchar* _tmp16_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = length;
				if (!(_tmp5_ < _tmp6_)) {
					break;
				}
				_tmp7_ = str;
				_tmp8_ = string_get_char (_tmp7_, (glong) 0);
				ch = _tmp8_;
				_tmp9_ = ch;
				switch (_tmp9_) {
					case '<':
					{
						GString* _tmp10_;
						_tmp10_ = buff;
						g_string_append (_tmp10_, "&lt;");
						break;
					}
					case '>':
					{
						GString* _tmp11_;
						_tmp11_ = buff;
						g_string_append (_tmp11_, "&gt;");
						break;
					}
					case '&':
					{
						GString* _tmp12_;
						_tmp12_ = buff;
						g_string_append (_tmp12_, "&amp;");
						break;
					}
					default:
					{
						GString* _tmp13_;
						gunichar _tmp14_;
						_tmp13_ = buff;
						_tmp14_ = ch;
						g_string_append_unichar (_tmp13_, _tmp14_);
						break;
					}
				}
				_tmp15_ = str;
				_tmp16_ = g_utf8_next_char (_tmp15_);
				str = _tmp16_;
			}
		}
	}
	_tmp17_ = buff;
	_tmp18_ = _tmp17_->str;
	_tmp19_ = g_strdup (_tmp18_);
	result = _tmp19_;
	_g_string_free0 (buff);
	return result;
}


static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	glong _tmp8_;
	glong _tmp14_;
	glong _tmp17_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	gchar* _tmp22_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_;
		glong _tmp4_;
		glong _tmp5_;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_;
		gint _tmp7_;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_;
		glong _tmp10_;
		glong _tmp11_;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_;
		glong _tmp13_;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_;
		glong _tmp16_;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static void ibus_emojier_update_annotations_with_description (IBusEmojiData* data, const gchar* description) {
	GSList* annotations = NULL;
	IBusEmojiData* _tmp0_;
	GSList* _tmp1_;
	GSList* _tmp2_;
	gboolean update_annotations = FALSE;
	gchar* former = NULL;
	gchar* later = NULL;
	gint index = 0;
	const gchar* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gchar** words = NULL;
	const gchar* _tmp20_;
	gchar** _tmp21_;
	gchar** _tmp22_;
	gint words_length1;
	gint _words_size_;
	gboolean _tmp23_ = FALSE;
	gchar** _tmp24_;
	gint _tmp24__length1;
	gboolean _tmp31_;
	g_return_if_fail (data != NULL);
	g_return_if_fail (description != NULL);
	_tmp0_ = data;
	_tmp1_ = ibus_emoji_data_get_annotations (_tmp0_);
	_tmp2_ = g_slist_copy_deep (_tmp1_, _g_strdup_gcopy_func, NULL);
	annotations = _tmp2_;
	update_annotations = FALSE;
	former = NULL;
	later = NULL;
	_tmp3_ = description;
	_tmp4_ = string_index_of (_tmp3_, ": ", 0);
	index = _tmp4_;
	_tmp5_ = index;
	if (_tmp5_ > 0) {
		const gchar* _tmp6_;
		gint _tmp7_;
		gchar* _tmp8_;
		GSList* _tmp9_;
		const gchar* _tmp10_;
		GCompareFunc _tmp11_;
		GSList* _tmp12_;
		const gchar* _tmp15_;
		gint _tmp16_;
		gchar* _tmp17_;
		_tmp6_ = description;
		_tmp7_ = index;
		_tmp8_ = string_substring (_tmp6_, (glong) 0, (glong) _tmp7_);
		_g_free0 (former);
		former = _tmp8_;
		_tmp9_ = annotations;
		_tmp10_ = former;
		_tmp11_ = g_strcmp0;
		_tmp12_ = g_slist_find_custom (_tmp9_, _tmp10_, _tmp11_);
		if (_tmp12_ == NULL) {
			const gchar* _tmp13_;
			gchar* _tmp14_;
			_tmp13_ = former;
			_tmp14_ = g_strdup (_tmp13_);
			annotations = g_slist_append (annotations, _tmp14_);
			update_annotations = TRUE;
		}
		_tmp15_ = description;
		_tmp16_ = index;
		_tmp17_ = string_substring (_tmp15_, (glong) (_tmp16_ + 2), (glong) -1);
		_g_free0 (later);
		later = _tmp17_;
	} else {
		const gchar* _tmp18_;
		gchar* _tmp19_;
		_tmp18_ = description;
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (later);
		later = _tmp19_;
	}
	_tmp20_ = later;
	_tmp22_ = _tmp21_ = g_strsplit (_tmp20_, " ", 0);
	words = _tmp22_;
	words_length1 = _vala_array_length (_tmp21_);
	_words_size_ = words_length1;
	_tmp24_ = words;
	_tmp24__length1 = words_length1;
	if (_tmp24__length1 < 3) {
		GSList* _tmp25_;
		const gchar* _tmp26_;
		GCompareFunc _tmp27_;
		GSList* _tmp28_;
		_tmp25_ = annotations;
		_tmp26_ = later;
		_tmp27_ = g_strcmp0;
		_tmp28_ = g_slist_find_custom (_tmp25_, _tmp26_, _tmp27_);
		_tmp23_ = _tmp28_ == NULL;
	} else {
		_tmp23_ = FALSE;
	}
	if (_tmp23_) {
		const gchar* _tmp29_;
		gchar* _tmp30_;
		_tmp29_ = later;
		_tmp30_ = g_strdup (_tmp29_);
		annotations = g_slist_append (annotations, _tmp30_);
		update_annotations = TRUE;
	}
	_tmp31_ = update_annotations;
	if (_tmp31_) {
		IBusEmojiData* _tmp32_;
		GSList* _tmp33_;
		GSList* _tmp34_;
		_tmp32_ = data;
		_tmp33_ = annotations;
		_tmp34_ = g_slist_copy_deep (_tmp33_, _g_strdup_gcopy_func, NULL);
		ibus_emoji_data_set_annotations (_tmp32_, _tmp34_);
	}
	words = (_vala_array_free (words, words_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (later);
	_g_free0 (former);
	__g_slist_free__g_free0_0 (annotations);
}


static void ibus_emojier_update_emoji_to_data_dict (IBusEmojiData* data, const gchar* lang) {
	gchar* emoji = NULL;
	IBusEmojiData* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (data != NULL);
	g_return_if_fail (lang != NULL);
	_tmp0_ = data;
	_tmp1_ = ibus_emoji_data_get_emoji (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	emoji = _tmp2_;
	_tmp3_ = lang;
	if (g_strcmp0 (_tmp3_, "en") == 0) {
		gchar* description = NULL;
		IBusEmojiData* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		IBusEmojiData* _tmp7_;
		const gchar* _tmp8_;
		GHashTable* _tmp9_;
		const gchar* _tmp10_;
		gchar* _tmp11_;
		IBusEmojiData* _tmp12_;
		IBusEmojiData* _tmp13_;
		_tmp4_ = data;
		_tmp5_ = ibus_emoji_data_get_description (_tmp4_);
		_tmp6_ = g_utf8_strdown (_tmp5_, (gssize) -1);
		description = _tmp6_;
		_tmp7_ = data;
		_tmp8_ = description;
		ibus_emojier_update_annotations_with_description (_tmp7_, _tmp8_);
		_tmp9_ = ibus_emojier_m_emoji_to_data_dict;
		_tmp10_ = emoji;
		_tmp11_ = g_strdup (_tmp10_);
		_tmp12_ = data;
		_tmp13_ = _g_object_ref0 (_tmp12_);
		g_hash_table_replace (_tmp9_, _tmp11_, _tmp13_);
		_g_free0 (description);
	} else {
		IBusEmojiData* en_data = NULL;
		GHashTable* _tmp14_;
		const gchar* _tmp15_;
		gconstpointer _tmp16_;
		IBusEmojiData* _tmp17_;
		gchar* trans_description = NULL;
		IBusEmojiData* _tmp23_;
		const gchar* _tmp24_;
		gchar* _tmp25_;
		IBusEmojiData* _tmp26_;
		const gchar* _tmp27_;
		const gchar* _tmp28_;
		gchar* _tmp29_;
		IBusEmojiData* _tmp30_;
		const gchar* _tmp31_;
		GSList* annotations = NULL;
		IBusEmojiData* _tmp32_;
		GSList* _tmp33_;
		GSList* en_annotations = NULL;
		IBusEmojiData* _tmp34_;
		GSList* _tmp35_;
		GSList* _tmp36_;
		IBusEmojiData* _tmp44_;
		GSList* _tmp45_;
		GSList* _tmp46_;
		en_data = NULL;
		_tmp14_ = ibus_emojier_m_emoji_to_data_dict;
		_tmp15_ = emoji;
		_tmp16_ = g_hash_table_lookup (_tmp14_, _tmp15_);
		en_data = (IBusEmojiData*) _tmp16_;
		_tmp17_ = en_data;
		if (_tmp17_ == NULL) {
			GHashTable* _tmp18_;
			const gchar* _tmp19_;
			gchar* _tmp20_;
			IBusEmojiData* _tmp21_;
			IBusEmojiData* _tmp22_;
			_tmp18_ = ibus_emojier_m_emoji_to_data_dict;
			_tmp19_ = emoji;
			_tmp20_ = g_strdup (_tmp19_);
			_tmp21_ = data;
			_tmp22_ = _g_object_ref0 (_tmp21_);
			g_hash_table_insert (_tmp18_, _tmp20_, _tmp22_);
			_g_free0 (emoji);
			return;
		}
		_tmp23_ = data;
		_tmp24_ = ibus_emoji_data_get_description (_tmp23_);
		_tmp25_ = g_strdup (_tmp24_);
		trans_description = _tmp25_;
		_tmp26_ = en_data;
		_tmp27_ = trans_description;
		ibus_emoji_data_set_description (_tmp26_, _tmp27_);
		_tmp28_ = trans_description;
		_tmp29_ = g_utf8_strdown (_tmp28_, (gssize) -1);
		_g_free0 (trans_description);
		trans_description = _tmp29_;
		_tmp30_ = data;
		_tmp31_ = trans_description;
		ibus_emojier_update_annotations_with_description (_tmp30_, _tmp31_);
		_tmp32_ = data;
		_tmp33_ = ibus_emoji_data_get_annotations (_tmp32_);
		annotations = _tmp33_;
		_tmp34_ = en_data;
		_tmp35_ = ibus_emoji_data_get_annotations (_tmp34_);
		en_annotations = _tmp35_;
		_tmp36_ = en_annotations;
		{
			GSList* annotation_collection = NULL;
			GSList* annotation_it = NULL;
			annotation_collection = _tmp36_;
			for (annotation_it = annotation_collection; annotation_it != NULL; annotation_it = annotation_it->next) {
				gchar* _tmp37_;
				gchar* annotation = NULL;
				_tmp37_ = g_strdup ((const gchar*) annotation_it->data);
				annotation = _tmp37_;
				{
					GSList* _tmp38_;
					const gchar* _tmp39_;
					GCompareFunc _tmp40_;
					GSList* _tmp41_;
					_tmp38_ = annotations;
					_tmp39_ = annotation;
					_tmp40_ = g_strcmp0;
					_tmp41_ = g_slist_find_custom (_tmp38_, _tmp39_, _tmp40_);
					if (_tmp41_ == NULL) {
						const gchar* _tmp42_;
						gchar* _tmp43_;
						_tmp42_ = annotation;
						_tmp43_ = g_strdup (_tmp42_);
						annotations = g_slist_append (annotations, _tmp43_);
					}
					_g_free0 (annotation);
				}
			}
		}
		_tmp44_ = en_data;
		_tmp45_ = annotations;
		_tmp46_ = g_slist_copy_deep (_tmp45_, _g_strdup_gcopy_func, NULL);
		ibus_emoji_data_set_annotations (_tmp44_, _tmp46_);
		_g_free0 (trans_description);
	}
	_g_free0 (emoji);
}


static gint string_index_of_char (const gchar* self, gunichar c, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_;
	gunichar _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = c;
	_tmp2_ = g_utf8_strchr (((gchar*) self) + _tmp0_, (gssize) -1, _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gchar* g_unichar_to_string (gunichar self) {
	gchar* result = NULL;
	gchar* str = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	_tmp0_ = g_new0 (gchar, 7);
	str = (gchar*) _tmp0_;
	_tmp1_ = str;
	g_unichar_to_utf8 (self, _tmp1_);
	result = str;
	return result;
}


static void ibus_emojier_update_category_to_emojis_dict (IBusEmojiData* data, const gchar* lang) {
	gchar* emoji = NULL;
	IBusEmojiData* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* category = NULL;
	IBusEmojiData* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp8_;
	g_return_if_fail (data != NULL);
	g_return_if_fail (lang != NULL);
	_tmp0_ = data;
	_tmp1_ = ibus_emoji_data_get_emoji (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	emoji = _tmp2_;
	_tmp3_ = data;
	_tmp4_ = ibus_emoji_data_get_category (_tmp3_);
	_tmp5_ = g_strdup (_tmp4_);
	category = _tmp5_;
	_tmp6_ = category;
	if (g_strcmp0 (_tmp6_, "") == 0) {
		gchar* _tmp7_;
		_tmp7_ = g_strdup (IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS);
		_g_free0 (category);
		category = _tmp7_;
	}
	_tmp8_ = lang;
	if (g_strcmp0 (_tmp8_, "en") == 0) {
		gboolean has_variant = FALSE;
		gboolean _tmp12_;
		gboolean has_emoji = FALSE;
		GSList* hits = NULL;
		GHashTable* _tmp46_;
		const gchar* _tmp47_;
		gconstpointer _tmp48_;
		GSList* _tmp49_;
		GSList* _tmp50_;
		gboolean _tmp54_;
		has_variant = FALSE;
		{
			gunichar* ch_collection = NULL;
			gint ch_collection_length1 = 0;
			gint _ch_collection_size_ = 0;
			gint ch_it = 0;
			ch_collection = IBUS_EMOJIER_EMOJI_VARIANT_LIST;
			ch_collection_length1 = G_N_ELEMENTS (IBUS_EMOJIER_EMOJI_VARIANT_LIST);
			for (ch_it = 0; ch_it < G_N_ELEMENTS (IBUS_EMOJIER_EMOJI_VARIANT_LIST); ch_it = ch_it + 1) {
				gunichar ch = 0U;
				ch = ch_collection[ch_it];
				{
					const gchar* _tmp9_;
					gunichar _tmp10_;
					gint _tmp11_;
					_tmp9_ = emoji;
					_tmp10_ = ch;
					_tmp11_ = string_index_of_char (_tmp9_, _tmp10_, 0);
					if (_tmp11_ >= 0) {
						has_variant = TRUE;
						break;
					}
				}
			}
		}
		_tmp12_ = has_variant;
		if (_tmp12_) {
			gunichar base_ch = 0U;
			const gchar* _tmp13_;
			gunichar _tmp14_;
			gchar* base_emoji = NULL;
			gunichar _tmp15_;
			gchar* _tmp16_;
			GString* buff = NULL;
			GString* _tmp17_;
			GString* _tmp18_;
			gunichar _tmp19_;
			GString* _tmp20_;
			GHashTable* _tmp21_;
			GString* _tmp22_;
			const gchar* _tmp23_;
			gconstpointer _tmp24_;
			GSList* variants = NULL;
			GHashTable* _tmp28_;
			const gchar* _tmp29_;
			gconstpointer _tmp30_;
			GSList* _tmp31_;
			GSList* _tmp32_;
			const gchar* _tmp33_;
			GCompareFunc _tmp34_;
			GSList* _tmp35_;
			_tmp13_ = emoji;
			_tmp14_ = string_get_char (_tmp13_, (glong) 0);
			base_ch = _tmp14_;
			_tmp15_ = base_ch;
			_tmp16_ = g_unichar_to_string (_tmp15_);
			base_emoji = _tmp16_;
			_tmp17_ = g_string_new ("");
			buff = _tmp17_;
			_tmp18_ = buff;
			_tmp19_ = base_ch;
			g_string_append_unichar (_tmp18_, _tmp19_);
			_tmp20_ = buff;
			g_string_append_unichar (_tmp20_, (gunichar) 0xfe0f);
			_tmp21_ = ibus_emojier_m_emoji_to_data_dict;
			_tmp22_ = buff;
			_tmp23_ = _tmp22_->str;
			_tmp24_ = g_hash_table_lookup (_tmp21_, _tmp23_);
			if (((IBusEmojiData*) _tmp24_) != NULL) {
				GString* _tmp25_;
				const gchar* _tmp26_;
				gchar* _tmp27_;
				_tmp25_ = buff;
				_tmp26_ = _tmp25_->str;
				_tmp27_ = g_strdup (_tmp26_);
				_g_free0 (base_emoji);
				base_emoji = _tmp27_;
			}
			_tmp28_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
			_tmp29_ = base_emoji;
			_tmp30_ = g_hash_table_lookup (_tmp28_, _tmp29_);
			_tmp31_ = g_slist_copy_deep ((GSList*) _tmp30_, _g_strdup_gcopy_func, NULL);
			variants = _tmp31_;
			_tmp32_ = variants;
			_tmp33_ = emoji;
			_tmp34_ = g_strcmp0;
			_tmp35_ = g_slist_find_custom (_tmp32_, _tmp33_, _tmp34_);
			if (_tmp35_ == NULL) {
				GSList* _tmp36_;
				const gchar* _tmp39_;
				gchar* _tmp40_;
				GHashTable* _tmp41_;
				const gchar* _tmp42_;
				gchar* _tmp43_;
				GSList* _tmp44_;
				GSList* _tmp45_;
				_tmp36_ = variants;
				if (_tmp36_ == NULL) {
					const gchar* _tmp37_;
					gchar* _tmp38_;
					_tmp37_ = base_emoji;
					_tmp38_ = g_strdup (_tmp37_);
					variants = g_slist_append (variants, _tmp38_);
				}
				_tmp39_ = emoji;
				_tmp40_ = g_strdup (_tmp39_);
				variants = g_slist_append (variants, _tmp40_);
				_tmp41_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
				_tmp42_ = base_emoji;
				_tmp43_ = g_strdup (_tmp42_);
				_tmp44_ = variants;
				_tmp45_ = g_slist_copy_deep (_tmp44_, _g_strdup_gcopy_func, NULL);
				g_hash_table_replace (_tmp41_, _tmp43_, _tmp45_);
			}
			__g_slist_free__g_free0_0 (variants);
			_g_string_free0 (buff);
			_g_free0 (base_emoji);
			_g_free0 (category);
			_g_free0 (emoji);
			return;
		}
		has_emoji = FALSE;
		_tmp46_ = ibus_emojier_m_category_to_emojis_dict;
		_tmp47_ = category;
		_tmp48_ = g_hash_table_lookup (_tmp46_, _tmp47_);
		_tmp49_ = g_slist_copy_deep ((GSList*) _tmp48_, _g_strdup_gcopy_func, NULL);
		hits = _tmp49_;
		_tmp50_ = hits;
		{
			GSList* hit_emoji_collection = NULL;
			GSList* hit_emoji_it = NULL;
			hit_emoji_collection = _tmp50_;
			for (hit_emoji_it = hit_emoji_collection; hit_emoji_it != NULL; hit_emoji_it = hit_emoji_it->next) {
				gchar* _tmp51_;
				gchar* hit_emoji = NULL;
				_tmp51_ = g_strdup ((const gchar*) hit_emoji_it->data);
				hit_emoji = _tmp51_;
				{
					const gchar* _tmp52_;
					const gchar* _tmp53_;
					_tmp52_ = hit_emoji;
					_tmp53_ = emoji;
					if (g_strcmp0 (_tmp52_, _tmp53_) == 0) {
						has_emoji = TRUE;
						_g_free0 (hit_emoji);
						break;
					}
					_g_free0 (hit_emoji);
				}
			}
		}
		_tmp54_ = has_emoji;
		if (!_tmp54_) {
			const gchar* _tmp55_;
			gchar* _tmp56_;
			GHashTable* _tmp57_;
			const gchar* _tmp58_;
			gchar* _tmp59_;
			GSList* _tmp60_;
			GSList* _tmp61_;
			_tmp55_ = emoji;
			_tmp56_ = g_strdup (_tmp55_);
			hits = g_slist_append (hits, _tmp56_);
			_tmp57_ = ibus_emojier_m_category_to_emojis_dict;
			_tmp58_ = category;
			_tmp59_ = g_strdup (_tmp58_);
			_tmp60_ = hits;
			_tmp61_ = g_slist_copy_deep (_tmp60_, _g_strdup_gcopy_func, NULL);
			g_hash_table_replace (_tmp57_, _tmp59_, _tmp61_);
		}
		__g_slist_free__g_free0_0 (hits);
	}
	_g_free0 (category);
	_g_free0 (emoji);
}


static void ibus_emojier_set_fixed_size (IBusEmojier* self) {
	g_return_if_fail (self != NULL);
	gtk_window_resize ((GtkWindow*) self, 20, 1);
}


static void ibus_emojier_remove_all_children (IBusEmojier* self) {
	GtkBox* _tmp0_;
	GList* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_vbox;
	_tmp1_ = gtk_container_get_children ((GtkContainer*) _tmp0_);
	{
		GList* w_collection = NULL;
		GList* w_it = NULL;
		w_collection = _tmp1_;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			GtkWidget* _tmp2_;
			GtkWidget* w = NULL;
			_tmp2_ = _g_object_ref0 ((GtkWidget*) w_it->data);
			w = _tmp2_;
			{
				gboolean _tmp3_ = FALSE;
				GtkWidget* _tmp4_;
				const gchar* _tmp5_;
				const gchar* _tmp6_;
				GtkWidget* _tmp10_;
				_tmp4_ = w;
				_tmp5_ = gtk_widget_get_name (_tmp4_);
				_tmp6_ = _tmp5_;
				if (g_strcmp0 (_tmp6_, "IBusEmojierEntry") == 0) {
					_tmp3_ = TRUE;
				} else {
					GtkWidget* _tmp7_;
					const gchar* _tmp8_;
					const gchar* _tmp9_;
					_tmp7_ = w;
					_tmp8_ = gtk_widget_get_name (_tmp7_);
					_tmp9_ = _tmp8_;
					_tmp3_ = g_strcmp0 (_tmp9_, "IBusEmojierTitleLabelBox") == 0;
				}
				if (_tmp3_) {
					_g_object_unref0 (w);
					continue;
				}
				_tmp10_ = w;
				gtk_widget_destroy (_tmp10_);
				_g_object_unref0 (w);
			}
		}
		_g_list_free0 (w_collection);
	}
}


static void __lambda13_ (IBusEmojier* self, GtkListBox* box, GtkListBoxRow* gtkrow) {
	IBusEmojierEBoxRow* row = NULL;
	GtkListBoxRow* _tmp0_;
	IBusEmojierEBoxRow* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	g_return_if_fail (box != NULL);
	g_return_if_fail (gtkrow != NULL);
	self->priv->m_category_active_index = 0;
	_tmp0_ = gtkrow;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, IBUS_EMOJIER_TYPE_EBOX_ROW) ? ((IBusEmojierEBoxRow*) _tmp0_) : NULL);
	row = _tmp1_;
	_tmp2_ = ibus_emojier_ebox_row_get_text (row);
	_tmp3_ = _tmp2_;
	ibus_emojier_show_emoji_for_category (self, _tmp3_);
	_g_object_unref0 (row);
}


static void ___lambda13__gtk_list_box_row_activated (GtkListBox* _sender, GtkListBoxRow* row, gpointer self) {
	__lambda13_ ((IBusEmojier*) self, _sender, row);
}


static gint __lambda14_ (const gchar* a, const gchar* b) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	GCompareFunc _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	gint _tmp9_;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp1_ = a;
	if (g_strcmp0 (_tmp1_, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) == 0) {
		const gchar* _tmp2_;
		_tmp2_ = b;
		_tmp0_ = g_strcmp0 (_tmp2_, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) != 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = 1;
		return result;
	} else {
		gboolean _tmp3_ = FALSE;
		const gchar* _tmp4_;
		_tmp4_ = a;
		if (g_strcmp0 (_tmp4_, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) != 0) {
			const gchar* _tmp5_;
			_tmp5_ = b;
			_tmp3_ = g_strcmp0 (_tmp5_, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) == 0;
		} else {
			_tmp3_ = FALSE;
		}
		if (_tmp3_) {
			result = -1;
			return result;
		}
	}
	_tmp6_ = g_strcmp0;
	_tmp7_ = a;
	_tmp8_ = b;
	_tmp9_ = _tmp6_ (_ (_tmp7_), _ (_tmp8_));
	result = _tmp9_;
	return result;
}


static gint ___lambda14__gcompare_func (gconstpointer a, gconstpointer b) {
	gint result;
	result = __lambda14_ ((const gchar*) a, (const gchar*) b);
	return result;
}


static void ibus_emojier_show_category_list (IBusEmojier* self) {
	IBusEmojierEScrolledWindow* _tmp0_;
	gchar* language = NULL;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	IBusEmojierETitleLabelBox* _tmp4_;
	const gchar* _tmp5_;
	GtkBox* _tmp6_;
	IBusEmojierEScrolledWindow* _tmp7_;
	GtkViewport* viewport = NULL;
	GtkViewport* _tmp8_;
	IBusEmojierEScrolledWindow* _tmp9_;
	GtkViewport* _tmp10_;
	IBusEmojierEListBox* _tmp11_;
	GtkViewport* _tmp12_;
	IBusEmojierEListBox* _tmp13_;
	GtkAdjustment* adjustment = NULL;
	IBusEmojierEScrolledWindow* _tmp14_;
	GtkAdjustment* _tmp15_;
	GtkAdjustment* _tmp16_;
	IBusEmojierEListBox* _tmp17_;
	GtkAdjustment* _tmp18_;
	IBusEmojierEListBox* _tmp19_;
	guint n = 0U;
	gchar** _tmp20_;
	gint _tmp20__length1;
	GList* categories = NULL;
	GHashTable* _tmp31_;
	GList* _tmp32_;
	GList* _tmp33_;
	IBusEmojierEScrolledWindow* _tmp47_;
	gint _tmp48_;
	IBusEmojierEListBox* _tmp50_;
	IBusEmojierEListBox* _tmp51_;
	g_return_if_fail (self != NULL);
	ibus_emojier_remove_all_children (self);
	_tmp0_ = ibus_emojier_escrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->m_scrolled_window);
	self->priv->m_scrolled_window = _tmp0_;
	ibus_emojier_set_fixed_size (self);
	_tmp1_ = ibus_emojier_m_current_lang_id;
	_tmp2_ = ibus_get_language_name (_tmp1_);
	_tmp3_ = g_strdup (_tmp2_);
	language = _tmp3_;
	_tmp4_ = self->priv->m_title;
	_tmp5_ = language;
	ibus_emojier_etitle_label_box_set_lang_label (_tmp4_, _tmp5_);
	_tmp6_ = self->priv->m_vbox;
	_tmp7_ = self->priv->m_scrolled_window;
	gtk_container_add ((GtkContainer*) _tmp6_, (GtkWidget*) _tmp7_);
	_tmp8_ = (GtkViewport*) gtk_viewport_new (NULL, NULL);
	g_object_ref_sink (_tmp8_);
	viewport = _tmp8_;
	_tmp9_ = self->priv->m_scrolled_window;
	_tmp10_ = viewport;
	gtk_container_add ((GtkContainer*) _tmp9_, (GtkWidget*) _tmp10_);
	_tmp11_ = ibus_emojier_elist_box_new ();
	g_object_ref_sink (_tmp11_);
	_g_object_unref0 (self->priv->m_list_box);
	self->priv->m_list_box = _tmp11_;
	_tmp12_ = viewport;
	_tmp13_ = self->priv->m_list_box;
	gtk_container_add ((GtkContainer*) _tmp12_, (GtkWidget*) _tmp13_);
	_tmp14_ = self->priv->m_scrolled_window;
	_tmp15_ = gtk_scrolled_window_get_vadjustment ((GtkScrolledWindow*) _tmp14_);
	_tmp16_ = _g_object_ref0 (_tmp15_);
	adjustment = _tmp16_;
	_tmp17_ = self->priv->m_list_box;
	_tmp18_ = adjustment;
	gtk_list_box_set_adjustment ((GtkListBox*) _tmp17_, _tmp18_);
	_tmp19_ = self->priv->m_list_box;
	g_signal_connect_object ((GtkListBox*) _tmp19_, "row-activated", (GCallback) ___lambda13__gtk_list_box_row_activated, self, 0);
	n = (guint) 1;
	_tmp20_ = ibus_emojier_m_favorites;
	_tmp20__length1 = ibus_emojier_m_favorites_length1;
	if (_tmp20__length1 > 0) {
		IBusEmojierEBoxRow* row = NULL;
		IBusEmojierEBoxRow* _tmp21_;
		IBusEmojierEPaddedLabelBox* widget = NULL;
		IBusEmojierEPaddedLabelBox* _tmp22_;
		IBusEmojierEBoxRow* _tmp23_;
		IBusEmojierEPaddedLabelBox* _tmp24_;
		IBusEmojierEListBox* _tmp25_;
		IBusEmojierEBoxRow* _tmp26_;
		guint _tmp27_;
		gint _tmp28_;
		_tmp21_ = ibus_emojier_ebox_row_new (IBUS_EMOJIER_EMOJI_CATEGORY_FAVORITES);
		g_object_ref_sink (_tmp21_);
		row = _tmp21_;
		_tmp22_ = ibus_emojier_epadded_label_box_new (_ (IBUS_EMOJIER_EMOJI_CATEGORY_FAVORITES), GTK_ALIGN_CENTER, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE);
		g_object_ref_sink (_tmp22_);
		widget = _tmp22_;
		_tmp23_ = row;
		_tmp24_ = widget;
		gtk_container_add ((GtkContainer*) _tmp23_, (GtkWidget*) _tmp24_);
		_tmp25_ = self->priv->m_list_box;
		_tmp26_ = row;
		gtk_container_add ((GtkContainer*) _tmp25_, (GtkWidget*) _tmp26_);
		_tmp27_ = n;
		n = _tmp27_ + 1;
		_tmp28_ = self->priv->m_category_active_index;
		if (_tmp27_ == ((guint) _tmp28_)) {
			IBusEmojierEListBox* _tmp29_;
			IBusEmojierEBoxRow* _tmp30_;
			_tmp29_ = self->priv->m_list_box;
			_tmp30_ = row;
			gtk_list_box_select_row ((GtkListBox*) _tmp29_, (GtkListBoxRow*) _tmp30_);
		}
		_g_object_unref0 (widget);
		_g_object_unref0 (row);
	}
	_tmp31_ = ibus_emojier_m_category_to_emojis_dict;
	_tmp32_ = g_hash_table_get_keys (_tmp31_);
	categories = _tmp32_;
	categories = g_list_sort (categories, ___lambda14__gcompare_func);
	_tmp33_ = categories;
	{
		GList* category_collection = NULL;
		GList* category_it = NULL;
		category_collection = _tmp33_;
		for (category_it = category_collection; category_it != NULL; category_it = category_it->next) {
			const gchar* category = NULL;
			category = (const gchar*) category_it->data;
			{
				const gchar* _tmp34_;
				IBusEmojierEBoxRow* row = NULL;
				const gchar* _tmp35_;
				IBusEmojierEBoxRow* _tmp36_;
				IBusEmojierEPaddedLabelBox* widget = NULL;
				const gchar* _tmp37_;
				IBusEmojierEPaddedLabelBox* _tmp38_;
				IBusEmojierEBoxRow* _tmp39_;
				IBusEmojierEPaddedLabelBox* _tmp40_;
				IBusEmojierEListBox* _tmp41_;
				IBusEmojierEBoxRow* _tmp42_;
				guint _tmp43_;
				gint _tmp44_;
				_tmp34_ = category;
				if (g_strcmp0 (_tmp34_, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) == 0) {
					continue;
				}
				_tmp35_ = category;
				_tmp36_ = ibus_emojier_ebox_row_new (_tmp35_);
				g_object_ref_sink (_tmp36_);
				row = _tmp36_;
				_tmp37_ = category;
				_tmp38_ = ibus_emojier_epadded_label_box_new (_ (_tmp37_), GTK_ALIGN_CENTER, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE);
				g_object_ref_sink (_tmp38_);
				widget = _tmp38_;
				_tmp39_ = row;
				_tmp40_ = widget;
				gtk_container_add ((GtkContainer*) _tmp39_, (GtkWidget*) _tmp40_);
				_tmp41_ = self->priv->m_list_box;
				_tmp42_ = row;
				gtk_container_add ((GtkContainer*) _tmp41_, (GtkWidget*) _tmp42_);
				_tmp43_ = n;
				n = _tmp43_ + 1;
				_tmp44_ = self->priv->m_category_active_index;
				if (_tmp43_ == ((guint) _tmp44_)) {
					IBusEmojierEListBox* _tmp45_;
					IBusEmojierEBoxRow* _tmp46_;
					_tmp45_ = self->priv->m_list_box;
					_tmp46_ = row;
					gtk_list_box_select_row ((GtkListBox*) _tmp45_, (GtkListBoxRow*) _tmp46_);
				}
				_g_object_unref0 (widget);
				_g_object_unref0 (row);
			}
		}
	}
	_tmp47_ = self->priv->m_scrolled_window;
	gtk_widget_show_all ((GtkWidget*) _tmp47_);
	_tmp48_ = self->priv->m_category_active_index;
	if (_tmp48_ == 0) {
		IBusEmojierEListBox* _tmp49_;
		_tmp49_ = self->priv->m_list_box;
		gtk_list_box_unselect_all ((GtkListBox*) _tmp49_);
	}
	_tmp50_ = self->priv->m_list_box;
	gtk_list_box_invalidate_filter ((GtkListBox*) _tmp50_);
	_tmp51_ = self->priv->m_list_box;
	gtk_list_box_set_selection_mode ((GtkListBox*) _tmp51_, GTK_SELECTION_SINGLE);
	_g_list_free0 (categories);
	_g_object_unref0 (adjustment);
	_g_object_unref0 (viewport);
	_g_free0 (language);
}


static void ibus_emojier_show_emoji_for_category (IBusEmojier* self, const gchar* category) {
	const gchar* _tmp0_;
	gint _tmp20_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (category != NULL);
	_tmp0_ = category;
	if (g_strcmp0 (_tmp0_, IBUS_EMOJIER_EMOJI_CATEGORY_FAVORITES) == 0) {
		IBusLookupTable* _tmp1_;
		gchar** _tmp2_;
		gint _tmp2__length1;
		const gchar* _tmp7_;
		gchar* _tmp8_;
		_tmp1_ = self->priv->m_lookup_table;
		ibus_lookup_table_clear (_tmp1_);
		_tmp2_ = ibus_emojier_m_favorites;
		_tmp2__length1 = ibus_emojier_m_favorites_length1;
		{
			gchar** favorate_collection = NULL;
			gint favorate_collection_length1 = 0;
			gint _favorate_collection_size_ = 0;
			gint favorate_it = 0;
			favorate_collection = _tmp2_;
			favorate_collection_length1 = _tmp2__length1;
			for (favorate_it = 0; favorate_it < _tmp2__length1; favorate_it = favorate_it + 1) {
				const gchar* favorate = NULL;
				favorate = favorate_collection[favorate_it];
				{
					IBusText* text = NULL;
					const gchar* _tmp3_;
					IBusText* _tmp4_;
					IBusLookupTable* _tmp5_;
					IBusText* _tmp6_;
					_tmp3_ = favorate;
					_tmp4_ = ibus_text_new_from_string (_tmp3_);
					g_object_ref_sink (_tmp4_);
					text = _tmp4_;
					_tmp5_ = self->priv->m_lookup_table;
					_tmp6_ = text;
					ibus_lookup_table_append_candidate (_tmp5_, _tmp6_);
					_g_object_unref0 (text);
				}
			}
		}
		_tmp7_ = category;
		_tmp8_ = g_strdup (_tmp7_);
		_g_free0 (self->priv->m_backward);
		self->priv->m_backward = _tmp8_;
	} else {
		GSList* emojis = NULL;
		GHashTable* _tmp9_;
		const gchar* _tmp10_;
		gconstpointer _tmp11_;
		IBusLookupTable* _tmp12_;
		GSList* _tmp13_;
		const gchar* _tmp18_;
		gchar* _tmp19_;
		_tmp9_ = ibus_emojier_m_category_to_emojis_dict;
		_tmp10_ = category;
		_tmp11_ = g_hash_table_lookup (_tmp9_, _tmp10_);
		emojis = (GSList*) _tmp11_;
		_tmp12_ = self->priv->m_lookup_table;
		ibus_lookup_table_clear (_tmp12_);
		_tmp13_ = emojis;
		{
			GSList* emoji_collection = NULL;
			GSList* emoji_it = NULL;
			emoji_collection = _tmp13_;
			for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
				const gchar* emoji = NULL;
				emoji = (const gchar*) emoji_it->data;
				{
					IBusText* text = NULL;
					const gchar* _tmp14_;
					IBusText* _tmp15_;
					IBusLookupTable* _tmp16_;
					IBusText* _tmp17_;
					_tmp14_ = emoji;
					_tmp15_ = ibus_text_new_from_string (_tmp14_);
					g_object_ref_sink (_tmp15_);
					text = _tmp15_;
					_tmp16_ = self->priv->m_lookup_table;
					_tmp17_ = text;
					ibus_lookup_table_append_candidate (_tmp16_, _tmp17_);
					_g_object_unref0 (text);
				}
			}
		}
		_tmp18_ = category;
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (self->priv->m_backward);
		self->priv->m_backward = _tmp19_;
	}
	_tmp20_ = self->priv->m_backward_index;
	if (_tmp20_ >= 0) {
		IBusLookupTable* _tmp21_;
		gint _tmp22_;
		_tmp21_ = self->priv->m_lookup_table;
		_tmp22_ = self->priv->m_backward_index;
		ibus_lookup_table_set_cursor_pos (_tmp21_, (guint) _tmp22_);
		self->priv->m_backward_index = -1;
	}
	ibus_emojier_show_candidate_panel (self);
}


static void ibus_emojier_show_emoji_variants (IBusEmojier* self, GSList* emojis) {
	IBusLookupTable* _tmp0_;
	guint _tmp1_;
	IBusLookupTable* _tmp2_;
	GSList* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_lookup_table;
	_tmp1_ = ibus_lookup_table_get_cursor_pos (_tmp0_);
	self->priv->m_backward_index = (gint) _tmp1_;
	_tmp2_ = self->priv->m_lookup_table;
	ibus_lookup_table_clear (_tmp2_);
	_tmp3_ = emojis;
	{
		GSList* emoji_collection = NULL;
		GSList* emoji_it = NULL;
		emoji_collection = _tmp3_;
		for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
			const gchar* emoji = NULL;
			emoji = (const gchar*) emoji_it->data;
			{
				IBusText* text = NULL;
				const gchar* _tmp4_;
				IBusText* _tmp5_;
				IBusLookupTable* _tmp6_;
				IBusText* _tmp7_;
				_tmp4_ = emoji;
				_tmp5_ = ibus_text_new_from_string (_tmp4_);
				g_object_ref_sink (_tmp5_);
				text = _tmp5_;
				_tmp6_ = self->priv->m_lookup_table;
				_tmp7_ = text;
				ibus_lookup_table_append_candidate (_tmp6_, _tmp7_);
				_g_object_unref0 (text);
			}
		}
	}
	ibus_emojier_show_candidate_panel (self);
}


static void __lambda18_ (IBusEmojier* self) {
	IBusLookupTable* _tmp0_;
	_tmp0_ = self->priv->m_lookup_table;
	ibus_lookup_table_page_down (_tmp0_);
	ibus_emojier_show_candidate_panel (self);
}


static void ___lambda18__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda18_ ((IBusEmojier*) self);
}


static void __lambda19_ (IBusEmojier* self) {
	IBusLookupTable* _tmp0_;
	_tmp0_ = self->priv->m_lookup_table;
	ibus_lookup_table_page_up (_tmp0_);
	ibus_emojier_show_candidate_panel (self);
}


static void ___lambda19__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda19_ ((IBusEmojier*) self);
}


static void ibus_emojier_show_arrow_buttons (IBusEmojier* self) {
	GtkButton* next_button = NULL;
	GtkButton* _tmp0_;
	GtkImage* _tmp1_;
	GtkImage* _tmp2_;
	GtkButton* prev_button = NULL;
	GtkButton* _tmp3_;
	GtkImage* _tmp4_;
	GtkImage* _tmp5_;
	GtkBox* buttons_hbox = NULL;
	GtkBox* _tmp6_;
	GtkLabel* state_label = NULL;
	GtkLabel* _tmp7_;
	GtkBox* _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkButton*) gtk_button_new ();
	g_object_ref_sink (_tmp0_);
	next_button = _tmp0_;
	g_signal_connect_object (next_button, "clicked", (GCallback) ___lambda18__gtk_button_clicked, self, 0);
	_tmp1_ = (GtkImage*) gtk_image_new_from_icon_name ("go-down", GTK_ICON_SIZE_MENU);
	g_object_ref_sink (_tmp1_);
	_tmp2_ = _tmp1_;
	gtk_button_set_image (next_button, (GtkWidget*) _tmp2_);
	_g_object_unref0 (_tmp2_);
	gtk_button_set_relief (next_button, GTK_RELIEF_NONE);
	gtk_widget_set_tooltip_text ((GtkWidget*) next_button, _ ("Page Down"));
	_tmp3_ = (GtkButton*) gtk_button_new ();
	g_object_ref_sink (_tmp3_);
	prev_button = _tmp3_;
	g_signal_connect_object (prev_button, "clicked", (GCallback) ___lambda19__gtk_button_clicked, self, 0);
	_tmp4_ = (GtkImage*) gtk_image_new_from_icon_name ("go-up", GTK_ICON_SIZE_MENU);
	g_object_ref_sink (_tmp4_);
	_tmp5_ = _tmp4_;
	gtk_button_set_image (prev_button, (GtkWidget*) _tmp5_);
	_g_object_unref0 (_tmp5_);
	gtk_button_set_relief (prev_button, GTK_RELIEF_NONE);
	gtk_widget_set_tooltip_text ((GtkWidget*) prev_button, _ ("Page Up"));
	_tmp6_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp6_);
	buttons_hbox = _tmp6_;
	_tmp7_ = (GtkLabel*) gtk_label_new (NULL);
	g_object_ref_sink (_tmp7_);
	state_label = _tmp7_;
	gtk_widget_set_size_request ((GtkWidget*) state_label, 10, -1);
	gtk_widget_set_halign ((GtkWidget*) state_label, GTK_ALIGN_CENTER);
	gtk_widget_set_valign ((GtkWidget*) state_label, GTK_ALIGN_CENTER);
	gtk_box_pack_start (buttons_hbox, (GtkWidget*) state_label, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start (buttons_hbox, (GtkWidget*) prev_button, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start (buttons_hbox, (GtkWidget*) next_button, FALSE, FALSE, (guint) 0);
	_tmp8_ = self->priv->m_vbox;
	gtk_box_pack_start (_tmp8_, (GtkWidget*) buttons_hbox, FALSE, FALSE, (guint) 0);
	gtk_widget_show_all ((GtkWidget*) buttons_hbox);
	_g_object_unref0 (state_label);
	_g_object_unref0 (buttons_hbox);
	_g_object_unref0 (prev_button);
	_g_object_unref0 (next_button);
}


static guint64 uint64_parse (const gchar* str) {
	guint64 result = 0ULL;
	const gchar* _tmp0_;
	guint64 _tmp1_;
	g_return_val_if_fail (str != NULL, 0ULL);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtoull (_tmp0_, NULL, (guint) 0);
	result = _tmp1_;
	return result;
}


static gboolean ibus_emojier_check_unicode_point (IBusEmojier* self) {
	gboolean result = FALSE;
	gchar* annotation = NULL;
	IBusEmojierEEntry* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	GString* buff = NULL;
	GString* _tmp3_;
	GString* retval = NULL;
	GString* _tmp4_;
	gunichar code = 0U;
	GString* _tmp30_;
	const gchar* _tmp31_;
	guint64 _tmp32_;
	gunichar _tmp33_;
	gboolean _tmp34_;
	GString* _tmp35_;
	gunichar _tmp36_;
	gchar* _tmp37_;
	gchar* _tmp38_;
	GString* _tmp39_;
	const gchar* _tmp40_;
	gchar* _tmp41_;
	const gchar* _tmp42_;
	IBusText* text = NULL;
	const gchar* _tmp43_;
	IBusText* _tmp44_;
	IBusLookupTable* _tmp45_;
	IBusText* _tmp46_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->m_entry;
	_tmp1_ = gtk_entry_get_text ((GtkEntry*) _tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	annotation = _tmp2_;
	_g_free0 (self->priv->m_unicode_point);
	self->priv->m_unicode_point = NULL;
	_tmp3_ = g_string_new ("0x");
	buff = _tmp3_;
	_tmp4_ = g_string_new ("");
	retval = _tmp4_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp5_ = FALSE;
			_tmp5_ = TRUE;
			while (TRUE) {
				gint _tmp7_;
				const gchar* _tmp8_;
				gint _tmp9_;
				gunichar ch = 0U;
				const gchar* _tmp10_;
				gint _tmp11_;
				gunichar _tmp12_;
				gunichar _tmp13_;
				gunichar _tmp14_;
				gboolean _tmp15_;
				gunichar _tmp26_;
				gboolean _tmp27_;
				GString* _tmp28_;
				gunichar _tmp29_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp5_ = FALSE;
				_tmp7_ = i;
				_tmp8_ = annotation;
				_tmp9_ = g_utf8_strlen (_tmp8_, (gssize) -1);
				if (!(_tmp7_ < _tmp9_)) {
					break;
				}
				_tmp10_ = annotation;
				_tmp11_ = i;
				_tmp12_ = string_get_char (_tmp10_, (glong) _tmp11_);
				ch = _tmp12_;
				_tmp13_ = ch;
				if (_tmp13_ == ((gunichar) 0)) {
					result = FALSE;
					_g_string_free0 (retval);
					_g_string_free0 (buff);
					_g_free0 (annotation);
					return result;
				}
				_tmp14_ = ch;
				_tmp15_ = g_unichar_isspace (_tmp14_);
				if (_tmp15_) {
					gunichar code = 0U;
					GString* _tmp16_;
					const gchar* _tmp17_;
					guint64 _tmp18_;
					GString* _tmp19_;
					gunichar _tmp20_;
					gboolean _tmp21_;
					GString* _tmp22_;
					gunichar _tmp23_;
					gchar* _tmp24_;
					gchar* _tmp25_;
					_tmp16_ = buff;
					_tmp17_ = _tmp16_->str;
					_tmp18_ = uint64_parse (_tmp17_);
					code = (gunichar) _tmp18_;
					_tmp19_ = buff;
					g_string_assign (_tmp19_, "0x");
					_tmp20_ = code;
					_tmp21_ = g_unichar_validate (_tmp20_);
					if (!_tmp21_) {
						result = FALSE;
						_g_string_free0 (retval);
						_g_string_free0 (buff);
						_g_free0 (annotation);
						return result;
					}
					_tmp22_ = retval;
					_tmp23_ = code;
					_tmp24_ = g_unichar_to_string (_tmp23_);
					_tmp25_ = _tmp24_;
					g_string_append (_tmp22_, _tmp25_);
					_g_free0 (_tmp25_);
					continue;
				}
				_tmp26_ = ch;
				_tmp27_ = g_unichar_isxdigit (_tmp26_);
				if (!_tmp27_) {
					result = FALSE;
					_g_string_free0 (retval);
					_g_string_free0 (buff);
					_g_free0 (annotation);
					return result;
				}
				_tmp28_ = buff;
				_tmp29_ = ch;
				g_string_append_unichar (_tmp28_, _tmp29_);
			}
		}
	}
	_tmp30_ = buff;
	_tmp31_ = _tmp30_->str;
	_tmp32_ = uint64_parse (_tmp31_);
	code = (gunichar) _tmp32_;
	_tmp33_ = code;
	_tmp34_ = g_unichar_validate (_tmp33_);
	if (!_tmp34_) {
		result = FALSE;
		_g_string_free0 (retval);
		_g_string_free0 (buff);
		_g_free0 (annotation);
		return result;
	}
	_tmp35_ = retval;
	_tmp36_ = code;
	_tmp37_ = g_unichar_to_string (_tmp36_);
	_tmp38_ = _tmp37_;
	g_string_append (_tmp35_, _tmp38_);
	_g_free0 (_tmp38_);
	_tmp39_ = retval;
	_tmp40_ = _tmp39_->str;
	_tmp41_ = g_strdup (_tmp40_);
	_g_free0 (self->priv->m_unicode_point);
	self->priv->m_unicode_point = _tmp41_;
	_tmp42_ = self->priv->m_unicode_point;
	if (_tmp42_ == NULL) {
		result = TRUE;
		_g_string_free0 (retval);
		_g_string_free0 (buff);
		_g_free0 (annotation);
		return result;
	}
	_tmp43_ = self->priv->m_unicode_point;
	_tmp44_ = ibus_text_new_from_string (_tmp43_);
	g_object_ref_sink (_tmp44_);
	text = _tmp44_;
	_tmp45_ = self->priv->m_lookup_table;
	_tmp46_ = text;
	ibus_lookup_table_append_candidate (_tmp45_, _tmp46_);
	result = TRUE;
	_g_object_unref0 (text);
	_g_string_free0 (retval);
	_g_string_free0 (buff);
	_g_free0 (annotation);
	return result;
}


static GSList* ibus_emojier_lookup_emojis_from_annotation (IBusEmojier* self, const gchar* annotation) {
	GSList* result = NULL;
	GSList* total_emojis = NULL;
	GSList* sub_emojis = NULL;
	gint length = 0;
	const gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (annotation != NULL, NULL);
	total_emojis = NULL;
	sub_emojis = NULL;
	_tmp0_ = annotation;
	_tmp1_ = strlen (_tmp0_);
	_tmp2_ = _tmp1_;
	length = _tmp2_;
	_tmp4_ = ibus_emojier_m_has_partial_match;
	if (_tmp4_) {
		gint _tmp5_;
		guint _tmp6_;
		_tmp5_ = length;
		_tmp6_ = ibus_emojier_m_partial_match_length;
		_tmp3_ = ((guint) _tmp5_) >= _tmp6_;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		GHashTable* _tmp7_;
		GList* _tmp8_;
		_tmp7_ = ibus_emojier_m_annotation_to_emojis_dict;
		_tmp8_ = g_hash_table_get_keys (_tmp7_);
		{
			GList* key_collection = NULL;
			GList* key_it = NULL;
			key_collection = _tmp8_;
			for (key_it = key_collection; key_it != NULL; key_it = key_it->next) {
				const gchar* key = NULL;
				key = (const gchar*) key_it->data;
				{
					const gchar* _tmp9_;
					gint _tmp10_;
					gint _tmp11_;
					gint _tmp12_;
					gboolean matched = FALSE;
					guint _tmp13_;
					gboolean _tmp23_;
					GHashTable* _tmp24_;
					const gchar* _tmp25_;
					gconstpointer _tmp26_;
					GSList* _tmp27_;
					_tmp9_ = key;
					_tmp10_ = strlen (_tmp9_);
					_tmp11_ = _tmp10_;
					_tmp12_ = length;
					if (_tmp11_ < _tmp12_) {
						continue;
					}
					matched = FALSE;
					_tmp13_ = ibus_emojier_m_partial_match_condition;
					switch (_tmp13_) {
						case 0:
						{
							const gchar* _tmp14_;
							const gchar* _tmp15_;
							gboolean _tmp16_;
							_tmp14_ = key;
							_tmp15_ = annotation;
							_tmp16_ = g_str_has_prefix (_tmp14_, _tmp15_);
							if (_tmp16_) {
								matched = TRUE;
							}
							break;
						}
						case 1:
						{
							const gchar* _tmp17_;
							const gchar* _tmp18_;
							gboolean _tmp19_;
							_tmp17_ = key;
							_tmp18_ = annotation;
							_tmp19_ = g_str_has_suffix (_tmp17_, _tmp18_);
							if (_tmp19_) {
								matched = TRUE;
							}
							break;
						}
						case 2:
						{
							const gchar* _tmp20_;
							const gchar* _tmp21_;
							gint _tmp22_;
							_tmp20_ = key;
							_tmp21_ = annotation;
							_tmp22_ = string_index_of (_tmp20_, _tmp21_, 0);
							if (_tmp22_ >= 0) {
								matched = TRUE;
							}
							break;
						}
						default:
						{
							break;
						}
					}
					_tmp23_ = matched;
					if (!_tmp23_) {
						continue;
					}
					_tmp24_ = ibus_emojier_m_annotation_to_emojis_dict;
					_tmp25_ = key;
					_tmp26_ = g_hash_table_lookup (_tmp24_, _tmp25_);
					sub_emojis = (GSList*) _tmp26_;
					_tmp27_ = sub_emojis;
					{
						GSList* emoji_collection = NULL;
						GSList* emoji_it = NULL;
						emoji_collection = _tmp27_;
						for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
							const gchar* emoji = NULL;
							emoji = (const gchar*) emoji_it->data;
							{
								GSList* _tmp28_;
								const gchar* _tmp29_;
								GCompareFunc _tmp30_;
								GSList* _tmp31_;
								_tmp28_ = total_emojis;
								_tmp29_ = emoji;
								_tmp30_ = g_strcmp0;
								_tmp31_ = g_slist_find_custom (_tmp28_, _tmp29_, _tmp30_);
								if (_tmp31_ == NULL) {
									const gchar* _tmp32_;
									gchar* _tmp33_;
									_tmp32_ = emoji;
									_tmp33_ = g_strdup (_tmp32_);
									total_emojis = g_slist_append (total_emojis, _tmp33_);
								}
							}
						}
					}
				}
			}
			_g_list_free0 (key_collection);
		}
	} else {
		GHashTable* _tmp34_;
		const gchar* _tmp35_;
		gconstpointer _tmp36_;
		GSList* _tmp37_;
		_tmp34_ = ibus_emojier_m_annotation_to_emojis_dict;
		_tmp35_ = annotation;
		_tmp36_ = g_hash_table_lookup (_tmp34_, _tmp35_);
		sub_emojis = (GSList*) _tmp36_;
		_tmp37_ = sub_emojis;
		{
			GSList* emoji_collection = NULL;
			GSList* emoji_it = NULL;
			emoji_collection = _tmp37_;
			for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
				const gchar* emoji = NULL;
				emoji = (const gchar*) emoji_it->data;
				{
					const gchar* _tmp38_;
					gchar* _tmp39_;
					_tmp38_ = emoji;
					_tmp39_ = g_strdup (_tmp38_);
					total_emojis = g_slist_append (total_emojis, _tmp39_);
				}
			}
		}
	}
	result = total_emojis;
	return result;
}


static void ibus_emojier_update_candidate_window (IBusEmojier* self) {
	gchar* annotation = NULL;
	IBusEmojierEEntry* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	const gchar* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	GSList* total_emojis = NULL;
	const gchar* _tmp10_;
	GSList* _tmp11_;
	GSList* _tmp12_;
	gboolean _tmp17_ = FALSE;
	GSList* _tmp18_;
	IBusLookupTable* _tmp20_;
	GSList* _tmp21_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_entry;
	_tmp1_ = gtk_entry_get_text ((GtkEntry*) _tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	annotation = _tmp2_;
	_tmp3_ = annotation;
	_tmp4_ = strlen (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_ == 0) {
		ibus_emojier_hide_candidate_panel (self);
		_g_free0 (self->priv->m_backward);
		self->priv->m_backward = NULL;
		_g_free0 (annotation);
		return;
	}
	_tmp6_ = annotation;
	_tmp7_ = strlen (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = ibus_emojier_m_emoji_max_seq_len;
	if (_tmp8_ > _tmp9_) {
		ibus_emojier_hide_candidate_panel (self);
		_g_free0 (annotation);
		return;
	}
	ibus_emojier_check_unicode_point (self);
	_tmp10_ = annotation;
	_tmp11_ = ibus_emojier_lookup_emojis_from_annotation (self, _tmp10_);
	total_emojis = _tmp11_;
	_tmp12_ = total_emojis;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_;
		gchar* _tmp14_;
		const gchar* _tmp15_;
		GSList* _tmp16_;
		_tmp13_ = annotation;
		_tmp14_ = g_utf8_strdown (_tmp13_, (gssize) -1);
		_g_free0 (annotation);
		annotation = _tmp14_;
		_tmp15_ = annotation;
		_tmp16_ = ibus_emojier_lookup_emojis_from_annotation (self, _tmp15_);
		__g_slist_free__g_free0_0 (total_emojis);
		total_emojis = _tmp16_;
	}
	_tmp18_ = total_emojis;
	if (_tmp18_ == NULL) {
		const gchar* _tmp19_;
		_tmp19_ = self->priv->m_unicode_point;
		_tmp17_ = _tmp19_ == NULL;
	} else {
		_tmp17_ = FALSE;
	}
	if (_tmp17_) {
		ibus_emojier_hide_candidate_panel (self);
		__g_slist_free__g_free0_0 (total_emojis);
		_g_free0 (annotation);
		return;
	}
	_tmp20_ = self->priv->m_lookup_table;
	ibus_lookup_table_clear (_tmp20_);
	ibus_emojier_check_unicode_point (self);
	_tmp21_ = total_emojis;
	{
		GSList* emoji_collection = NULL;
		GSList* emoji_it = NULL;
		emoji_collection = _tmp21_;
		for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
			const gchar* emoji = NULL;
			emoji = (const gchar*) emoji_it->data;
			{
				IBusText* text = NULL;
				const gchar* _tmp22_;
				IBusText* _tmp23_;
				IBusLookupTable* _tmp24_;
				IBusText* _tmp25_;
				_tmp22_ = emoji;
				_tmp23_ = ibus_text_new_from_string (_tmp22_);
				g_object_ref_sink (_tmp23_);
				text = _tmp23_;
				_tmp24_ = self->priv->m_lookup_table;
				_tmp25_ = text;
				ibus_lookup_table_append_candidate (_tmp24_, _tmp25_);
				_g_object_unref0 (text);
			}
		}
	}
	ibus_emojier_show_candidate_panel (self);
	__g_slist_free__g_free0_0 (total_emojis);
	_g_free0 (annotation);
}


static void ibus_emojier_show_code_point_description (IBusEmojier* self, const gchar* text) {
	IBusEmojierEPaddedLabelBox* widget_code = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	IBusEmojierEPaddedLabelBox* _tmp5_;
	IBusEmojierEPaddedLabelBox* _tmp6_;
	GtkBox* _tmp7_;
	IBusEmojierEPaddedLabelBox* _tmp8_;
	IBusEmojierEPaddedLabelBox* _tmp9_;
	GHashTable* _tmp10_;
	const gchar* _tmp11_;
	gconstpointer _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = text;
	_tmp1_ = ibus_emojier_utf8_code_point (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf (_ ("Code point: %s"), _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = ibus_emojier_epadded_label_box_new (_tmp4_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE);
	g_object_ref_sink (_tmp5_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	widget_code = _tmp6_;
	_tmp7_ = self->priv->m_vbox;
	_tmp8_ = widget_code;
	gtk_container_add ((GtkContainer*) _tmp7_, (GtkWidget*) _tmp8_);
	_tmp9_ = widget_code;
	gtk_widget_show_all ((GtkWidget*) _tmp9_);
	_tmp10_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
	_tmp11_ = text;
	_tmp12_ = g_hash_table_lookup (_tmp10_, _tmp11_);
	if (((GSList*) _tmp12_) != NULL) {
		IBusEmojierEPaddedLabelBox* widget_has_variant = NULL;
		IBusEmojierEPaddedLabelBox* _tmp13_;
		GtkBox* _tmp14_;
		IBusEmojierEPaddedLabelBox* _tmp15_;
		IBusEmojierEPaddedLabelBox* _tmp16_;
		_tmp13_ = ibus_emojier_epadded_label_box_new (_ ("Has emoji variants"), GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE);
		g_object_ref_sink (_tmp13_);
		widget_has_variant = _tmp13_;
		_tmp14_ = self->priv->m_vbox;
		_tmp15_ = widget_has_variant;
		gtk_container_add ((GtkContainer*) _tmp14_, (GtkWidget*) _tmp15_);
		_tmp16_ = widget_has_variant;
		gtk_widget_show_all ((GtkWidget*) _tmp16_);
		_g_object_unref0 (widget_has_variant);
	}
	_g_object_unref0 (widget_code);
}


static gboolean ___lambda12_ (IBusEmojier* self, GtkWidget* w, GdkEventButton* e) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	g_return_val_if_fail (w != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp1_ = self->priv->m_backward_index;
	if (_tmp1_ >= 0) {
		const gchar* _tmp2_;
		_tmp2_ = self->priv->m_backward;
		_tmp0_ = _tmp2_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		const gchar* _tmp3_;
		_tmp3_ = self->priv->m_backward;
		ibus_emojier_show_emoji_for_category (self, _tmp3_);
	} else {
		ibus_emojier_hide_candidate_panel (self);
	}
	result = TRUE;
	return result;
}


static gboolean ____lambda12__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = ___lambda12_ ((IBusEmojier*) self, _sender, event);
	return result;
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		IBusEmojier* self;
		self = _data4_->self;
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static gboolean _____lambda15_ (Block4Data* _data4_, GtkWidget* w, GdkEventButton* e) {
	IBusEmojier* self;
	gboolean result = FALSE;
	guint _tmp0_;
	GdkEventButton* _tmp1_;
	guint _tmp2_;
	GdkEventButton* _tmp3_;
	GdkModifierType _tmp4_;
	self = _data4_->self;
	g_return_val_if_fail (w != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = _data4_->index;
	_tmp1_ = e;
	_tmp2_ = _tmp1_->button;
	_tmp3_ = e;
	_tmp4_ = _tmp3_->state;
	g_signal_emit (self, ibus_emojier_signals[IBUS_EMOJIER_CANDIDATE_CLICKED_SIGNAL], 0, _tmp0_, _tmp2_, (guint) _tmp4_);
	result = TRUE;
	return result;
}


static gboolean ______lambda15__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = _____lambda15_ (self, _sender, event);
	return result;
}


static GdkEventMotion* _vala_GdkEventMotion_copy (GdkEventMotion* self) {
	return g_boxed_copy (gdk_event_get_type (), self);
}


static gpointer __vala_GdkEventMotion_copy0 (gpointer self) {
	return self ? _vala_GdkEventMotion_copy (self) : NULL;
}


static void _vala_GdkEventMotion_free (GdkEventMotion* self) {
	g_boxed_free (gdk_event_get_type (), self);
}


static gboolean __lambda17_ (IBusEmojier* self) {
	gboolean result = FALSE;
	ibus_emojier_show_candidate_panel (self);
	result = FALSE;
	return result;
}


static gboolean ___lambda17__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda17_ ((IBusEmojier*) self);
	return result;
}


static gboolean _____lambda16_ (Block4Data* _data4_, GdkEventMotion* e) {
	IBusEmojier* self;
	gboolean result = FALSE;
	gboolean _tmp0_;
	IBusLookupTable* _tmp1_;
	guint _tmp2_;
	guint _tmp3_;
	GdkEventMotion* pe = NULL;
	GdkEventMotion* _tmp4_;
	GdkEventMotion* _tmp5_;
	gboolean _tmp6_ = FALSE;
	gdouble _tmp7_;
	GdkEventMotion* _tmp8_;
	gdouble _tmp9_;
	GdkEventMotion* _tmp13_;
	gdouble _tmp14_;
	GdkEventMotion* _tmp15_;
	gdouble _tmp16_;
	IBusLookupTable* _tmp17_;
	guint _tmp18_;
	gboolean _tmp19_ = FALSE;
	guint _tmp20_;
	guint _tmp25_;
	self = _data4_->self;
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = self->priv->m_enter_notify_enable;
	if (!_tmp0_) {
		result = FALSE;
		return result;
	}
	_tmp1_ = self->priv->m_lookup_table;
	_tmp2_ = ibus_lookup_table_get_cursor_pos (_tmp1_);
	_tmp3_ = _data4_->index;
	if (_tmp2_ == _tmp3_) {
		result = FALSE;
		return result;
	}
	_tmp4_ = e;
	_tmp5_ = __vala_GdkEventMotion_copy0 (_tmp4_);
	pe = _tmp5_;
	_tmp7_ = ibus_emojier_m_mouse_x;
	_tmp8_ = pe;
	_tmp9_ = _tmp8_->x_root;
	if (_tmp7_ == _tmp9_) {
		gdouble _tmp10_;
		GdkEventMotion* _tmp11_;
		gdouble _tmp12_;
		_tmp10_ = ibus_emojier_m_mouse_y;
		_tmp11_ = pe;
		_tmp12_ = _tmp11_->y_root;
		_tmp6_ = _tmp10_ == _tmp12_;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		result = FALSE;
		__vala_GdkEventMotion_free0 (pe);
		return result;
	}
	_tmp13_ = pe;
	_tmp14_ = _tmp13_->x_root;
	ibus_emojier_m_mouse_x = _tmp14_;
	_tmp15_ = pe;
	_tmp16_ = _tmp15_->y_root;
	ibus_emojier_m_mouse_y = _tmp16_;
	_tmp17_ = self->priv->m_lookup_table;
	_tmp18_ = _data4_->index;
	ibus_lookup_table_set_cursor_pos (_tmp17_, _tmp18_);
	_tmp20_ = self->priv->m_entry_notify_show_id;
	if (_tmp20_ > ((guint) 0)) {
		GMainContext* _tmp21_;
		guint _tmp22_;
		GSource* _tmp23_;
		_tmp21_ = g_main_context_default ();
		_tmp22_ = self->priv->m_entry_notify_show_id;
		_tmp23_ = g_main_context_find_source_by_id (_tmp21_, _tmp22_);
		_tmp19_ = _tmp23_ != NULL;
	} else {
		_tmp19_ = FALSE;
	}
	if (_tmp19_) {
		guint _tmp24_;
		_tmp24_ = self->priv->m_entry_notify_show_id;
		g_source_remove (_tmp24_);
	}
	_tmp25_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, ___lambda17__gsource_func, g_object_ref (self), g_object_unref);
	self->priv->m_entry_notify_show_id = _tmp25_;
	result = FALSE;
	__vala_GdkEventMotion_free0 (pe);
	return result;
}


static gboolean ______lambda16__gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = _____lambda16_ (self, event);
	return result;
}


static void _vala_array_add8 (GtkLabel** * array, int* length, int* size, GtkLabel* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkLabel*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void ibus_emojier_show_candidate_panel (IBusEmojier* self) {
	guint page_size = 0U;
	IBusLookupTable* _tmp0_;
	guint _tmp1_;
	guint ncandidates = 0U;
	IBusLookupTable* _tmp2_;
	guint _tmp3_;
	guint cursor = 0U;
	IBusLookupTable* _tmp4_;
	guint _tmp5_;
	guint page_start_pos = 0U;
	guint _tmp6_;
	guint _tmp7_;
	guint _tmp8_;
	guint page_end_pos = 0U;
	guint _tmp9_;
	guint _tmp10_;
	guint _tmp11_;
	guint _tmp12_;
	const gchar* _tmp13_;
	IBusEmojierEGrid* grid = NULL;
	IBusEmojierEGrid* _tmp27_;
	gint n = 0;
	gint _tmp90_;
	g_return_if_fail (self != NULL);
	ibus_emojier_remove_all_children (self);
	ibus_emojier_set_fixed_size (self);
	_tmp0_ = self->priv->m_lookup_table;
	_tmp1_ = ibus_lookup_table_get_page_size (_tmp0_);
	page_size = _tmp1_;
	_tmp2_ = self->priv->m_lookup_table;
	_tmp3_ = ibus_lookup_table_get_number_of_candidates (_tmp2_);
	ncandidates = _tmp3_;
	_tmp4_ = self->priv->m_lookup_table;
	_tmp5_ = ibus_lookup_table_get_cursor_pos (_tmp4_);
	cursor = _tmp5_;
	_tmp6_ = cursor;
	_tmp7_ = page_size;
	_tmp8_ = page_size;
	page_start_pos = (_tmp6_ / _tmp7_) * _tmp8_;
	_tmp9_ = page_start_pos;
	_tmp10_ = page_size;
	_tmp11_ = ncandidates;
	_tmp12_ = MIN (_tmp9_ + _tmp10_, _tmp11_);
	page_end_pos = _tmp12_;
	_tmp13_ = self->priv->m_backward;
	if (_tmp13_ != NULL) {
		gchar* backward_desc = NULL;
		const gchar* _tmp14_;
		guint _tmp15_;
		guint _tmp16_;
		gchar* _tmp17_;
		IBusEmojierEPaddedLabelBox* label = NULL;
		const gchar* _tmp18_;
		IBusEmojierEPaddedLabelBox* _tmp19_;
		GtkButton* button = NULL;
		GtkButton* _tmp20_;
		GtkButton* _tmp21_;
		IBusEmojierEPaddedLabelBox* _tmp22_;
		GtkBox* _tmp23_;
		GtkButton* _tmp24_;
		GtkButton* _tmp25_;
		GtkButton* _tmp26_;
		_tmp14_ = self->priv->m_backward;
		_tmp15_ = cursor;
		_tmp16_ = ncandidates;
		_tmp17_ = g_strdup_printf ("%s (%u / %u)", _ (_tmp14_), _tmp15_, _tmp16_ - 1);
		backward_desc = _tmp17_;
		_tmp18_ = backward_desc;
		_tmp19_ = ibus_emojier_epadded_label_box_new (_tmp18_, GTK_ALIGN_CENTER, IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD);
		g_object_ref_sink (_tmp19_);
		label = _tmp19_;
		_tmp20_ = (GtkButton*) gtk_button_new ();
		g_object_ref_sink (_tmp20_);
		button = _tmp20_;
		_tmp21_ = button;
		_tmp22_ = label;
		gtk_container_add ((GtkContainer*) _tmp21_, (GtkWidget*) _tmp22_);
		_tmp23_ = self->priv->m_vbox;
		_tmp24_ = button;
		gtk_container_add ((GtkContainer*) _tmp23_, (GtkWidget*) _tmp24_);
		_tmp25_ = button;
		gtk_widget_show_all ((GtkWidget*) _tmp25_);
		_tmp26_ = button;
		g_signal_connect_object ((GtkWidget*) _tmp26_, "button-press-event", (GCallback) ____lambda12__gtk_widget_button_press_event, self, 0);
		_g_object_unref0 (button);
		_g_object_unref0 (label);
		_g_free0 (backward_desc);
	}
	_tmp27_ = ibus_emojier_egrid_new ();
	g_object_ref_sink (_tmp27_);
	grid = _tmp27_;
	n = 0;
	{
		guint i = 0U;
		guint _tmp28_;
		_tmp28_ = page_start_pos;
		i = _tmp28_;
		{
			gboolean _tmp29_ = FALSE;
			_tmp29_ = TRUE;
			while (TRUE) {
				Block4Data* _data4_;
				guint _tmp31_;
				guint _tmp32_;
				gchar* text = NULL;
				IBusLookupTable* _tmp33_;
				guint _tmp34_;
				IBusText* _tmp35_;
				const gchar* _tmp36_;
				gchar* _tmp37_;
				gboolean has_variant = FALSE;
				GHashTable* _tmp38_;
				const gchar* _tmp39_;
				gconstpointer _tmp40_;
				GtkLabel* label = NULL;
				guint _tmp41_;
				guint _tmp42_;
				const gchar* _tmp57_;
				gint _tmp58_;
				GtkLabel* _tmp73_;
				GtkLabel* _tmp74_;
				GtkEventBox* candidate_ebox = NULL;
				GtkEventBox* _tmp75_;
				GtkEventBox* _tmp76_;
				GtkEventBox* _tmp77_;
				GtkLabel* _tmp78_;
				guint _tmp79_;
				GtkEventBox* _tmp80_;
				GtkEventBox* _tmp81_;
				IBusEmojierEGrid* _tmp82_;
				GtkEventBox* _tmp83_;
				gint _tmp84_;
				gint _tmp85_;
				gint _tmp86_;
				GtkLabel** _tmp87_;
				gint _tmp87__length1;
				GtkLabel* _tmp88_;
				GtkLabel* _tmp89_;
				_data4_ = g_slice_new0 (Block4Data);
				_data4_->_ref_count_ = 1;
				_data4_->self = g_object_ref (self);
				if (!_tmp29_) {
					guint _tmp30_;
					_tmp30_ = i;
					i = _tmp30_ + 1;
				}
				_tmp29_ = FALSE;
				_tmp31_ = i;
				_tmp32_ = page_end_pos;
				if (!(_tmp31_ < _tmp32_)) {
					block4_data_unref (_data4_);
					_data4_ = NULL;
					break;
				}
				_tmp33_ = self->priv->m_lookup_table;
				_tmp34_ = i;
				_tmp35_ = ibus_lookup_table_get_candidate (_tmp33_, _tmp34_);
				_tmp36_ = _tmp35_->text;
				_tmp37_ = g_strdup (_tmp36_);
				text = _tmp37_;
				_tmp38_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
				_tmp39_ = text;
				_tmp40_ = g_hash_table_lookup (_tmp38_, _tmp39_);
				has_variant = ((GSList*) _tmp40_) != NULL;
				_tmp41_ = i;
				_tmp42_ = cursor;
				if (_tmp41_ == _tmp42_) {
					const gchar* _tmp43_;
					IBusEmojierESelectedLabel* _tmp44_;
					GtkLabel* _tmp45_;
					_tmp43_ = text;
					_tmp44_ = ibus_emojier_eselected_label_new (_tmp43_);
					g_object_ref_sink (_tmp44_);
					_tmp45_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp44_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp44_) : NULL;
					if (_tmp45_ == NULL) {
						_g_object_unref0 (_tmp44_);
					}
					_g_object_unref0 (label);
					label = _tmp45_;
				} else {
					gboolean _tmp46_ = FALSE;
					gboolean _tmp47_ = FALSE;
					gboolean _tmp48_;
					_tmp48_ = ibus_emojier_m_show_emoji_variant;
					if (_tmp48_) {
						gboolean _tmp49_;
						_tmp49_ = has_variant;
						_tmp47_ = _tmp49_;
					} else {
						_tmp47_ = FALSE;
					}
					if (_tmp47_) {
						gint _tmp50_;
						_tmp50_ = self->priv->m_backward_index;
						_tmp46_ = _tmp50_ < 0;
					} else {
						_tmp46_ = FALSE;
					}
					if (_tmp46_) {
						const gchar* _tmp51_;
						IBusEmojierEGoldLabel* _tmp52_;
						GtkLabel* _tmp53_;
						_tmp51_ = text;
						_tmp52_ = ibus_emojier_egold_label_new (_tmp51_);
						g_object_ref_sink (_tmp52_);
						_tmp53_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp52_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp52_) : NULL;
						if (_tmp53_ == NULL) {
							_g_object_unref0 (_tmp52_);
						}
						_g_object_unref0 (label);
						label = _tmp53_;
					} else {
						const gchar* _tmp54_;
						IBusEmojierEWhiteLabel* _tmp55_;
						GtkLabel* _tmp56_;
						_tmp54_ = text;
						_tmp55_ = ibus_emojier_ewhite_label_new (_tmp54_);
						g_object_ref_sink (_tmp55_);
						_tmp56_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp55_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp55_) : NULL;
						if (_tmp56_ == NULL) {
							_g_object_unref0 (_tmp55_);
						}
						_g_object_unref0 (label);
						label = _tmp56_;
					}
				}
				_tmp57_ = text;
				_tmp58_ = g_utf8_strlen (_tmp57_, (gssize) -1);
				if (_tmp58_ > 2) {
					gchar* font_family = NULL;
					const gchar* _tmp59_;
					gchar* _tmp60_;
					gint font_size = 0;
					gint _tmp61_;
					gchar* emoji_font = NULL;
					const gchar* _tmp62_;
					gint _tmp63_;
					gchar* _tmp64_;
					gchar* markup = NULL;
					const gchar* _tmp65_;
					const gchar* _tmp66_;
					gchar* _tmp67_;
					gchar* _tmp68_;
					gchar* _tmp69_;
					gchar* _tmp70_;
					GtkLabel* _tmp71_;
					const gchar* _tmp72_;
					_tmp59_ = ibus_emojier_m_emoji_font_family;
					_tmp60_ = g_strdup (_tmp59_);
					font_family = _tmp60_;
					_tmp61_ = ibus_emojier_m_emoji_font_size;
					font_size = _tmp61_ - 2;
					_tmp62_ = font_family;
					_tmp63_ = font_size;
					_tmp64_ = g_strdup_printf ("%s %d", _tmp62_, _tmp63_);
					emoji_font = _tmp64_;
					_tmp65_ = emoji_font;
					_tmp66_ = text;
					_tmp67_ = ibus_emojier_utf8_entity (_tmp66_);
					_tmp68_ = _tmp67_;
					_tmp69_ = g_strdup_printf ("<span font=\"%s\">%s</span>", _tmp65_, _tmp68_);
					_tmp70_ = _tmp69_;
					_g_free0 (_tmp68_);
					markup = _tmp70_;
					_tmp71_ = label;
					_tmp72_ = markup;
					gtk_label_set_markup (_tmp71_, _tmp72_);
					_g_free0 (markup);
					_g_free0 (emoji_font);
					_g_free0 (font_family);
				}
				_tmp73_ = label;
				gtk_widget_set_halign ((GtkWidget*) _tmp73_, GTK_ALIGN_FILL);
				_tmp74_ = label;
				gtk_widget_set_valign ((GtkWidget*) _tmp74_, GTK_ALIGN_FILL);
				_tmp75_ = (GtkEventBox*) gtk_event_box_new ();
				g_object_ref_sink (_tmp75_);
				candidate_ebox = _tmp75_;
				_tmp76_ = candidate_ebox;
				gtk_widget_add_events ((GtkWidget*) _tmp76_, (gint) GDK_POINTER_MOTION_MASK);
				_tmp77_ = candidate_ebox;
				_tmp78_ = label;
				gtk_container_add ((GtkContainer*) _tmp77_, (GtkWidget*) _tmp78_);
				_tmp79_ = i;
				_data4_->index = _tmp79_;
				_tmp80_ = candidate_ebox;
				g_signal_connect_data ((GtkWidget*) _tmp80_, "button-press-event", (GCallback) ______lambda15__gtk_widget_button_press_event, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
				_tmp81_ = candidate_ebox;
				g_signal_connect_data ((GtkWidget*) _tmp81_, "motion-notify-event", (GCallback) ______lambda16__gtk_widget_motion_notify_event, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
				_tmp82_ = grid;
				_tmp83_ = candidate_ebox;
				_tmp84_ = n;
				_tmp85_ = n;
				gtk_grid_attach ((GtkGrid*) _tmp82_, (GtkWidget*) _tmp83_, _tmp84_ % ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE), _tmp85_ / ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE), 1, 1);
				_tmp86_ = n;
				n = _tmp86_ + 1;
				_tmp87_ = self->priv->m_candidates;
				_tmp87__length1 = self->priv->m_candidates_length1;
				_tmp88_ = label;
				_tmp89_ = _g_object_ref0 (_tmp88_);
				_vala_array_add8 (&self->priv->m_candidates, &self->priv->m_candidates_length1, &self->priv->_m_candidates_size_, _tmp89_);
				_g_object_unref0 (candidate_ebox);
				_g_object_unref0 (label);
				_g_free0 (text);
				block4_data_unref (_data4_);
				_data4_ = NULL;
			}
		}
	}
	_tmp90_ = n;
	if (_tmp90_ > 0) {
		GtkBox* _tmp91_;
		IBusEmojierEGrid* _tmp92_;
		IBusEmojierEGrid* _tmp93_;
		gchar* text = NULL;
		IBusLookupTable* _tmp94_;
		guint _tmp95_;
		IBusText* _tmp96_;
		const gchar* _tmp97_;
		gchar* _tmp98_;
		IBusEmojiData* data = NULL;
		GHashTable* _tmp99_;
		const gchar* _tmp100_;
		gconstpointer _tmp101_;
		IBusEmojiData* _tmp102_;
		GSList* annotations = NULL;
		IBusEmojiData* _tmp121_;
		GSList* _tmp122_;
		GString* buff = NULL;
		GString* _tmp123_;
		gint i = 0;
		GSList* _tmp124_;
		GString* _tmp140_;
		const gchar* _tmp141_;
		const gchar* _tmp148_;
		self->priv->m_candidate_panel_is_visible = TRUE;
		ibus_emojier_show_arrow_buttons (self);
		_tmp91_ = self->priv->m_vbox;
		_tmp92_ = grid;
		gtk_container_add ((GtkContainer*) _tmp91_, (GtkWidget*) _tmp92_);
		_tmp93_ = grid;
		gtk_widget_show_all ((GtkWidget*) _tmp93_);
		_tmp94_ = self->priv->m_lookup_table;
		_tmp95_ = cursor;
		_tmp96_ = ibus_lookup_table_get_candidate (_tmp94_, _tmp95_);
		_tmp97_ = _tmp96_->text;
		_tmp98_ = g_strdup (_tmp97_);
		text = _tmp98_;
		_tmp99_ = ibus_emojier_m_emoji_to_data_dict;
		_tmp100_ = text;
		_tmp101_ = g_hash_table_lookup (_tmp99_, _tmp100_);
		data = (IBusEmojiData*) _tmp101_;
		_tmp102_ = data;
		if (_tmp102_ == NULL) {
			IBusEmojierEPaddedLabelBox* widget = NULL;
			gchar* _tmp103_;
			gchar* _tmp104_;
			IBusEmojierEPaddedLabelBox* _tmp105_;
			IBusEmojierEPaddedLabelBox* _tmp106_;
			GtkBox* _tmp107_;
			IBusEmojierEPaddedLabelBox* _tmp108_;
			IBusEmojierEPaddedLabelBox* _tmp109_;
			const gchar* _tmp110_;
			_tmp103_ = g_strdup_printf (_ ("Description: %s"), _ ("None"));
			_tmp104_ = _tmp103_;
			_tmp105_ = ibus_emojier_epadded_label_box_new (_tmp104_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE);
			g_object_ref_sink (_tmp105_);
			_tmp106_ = _tmp105_;
			_g_free0 (_tmp104_);
			widget = _tmp106_;
			_tmp107_ = self->priv->m_vbox;
			_tmp108_ = widget;
			gtk_container_add ((GtkContainer*) _tmp107_, (GtkWidget*) _tmp108_);
			_tmp109_ = widget;
			gtk_widget_show_all ((GtkWidget*) _tmp109_);
			_tmp110_ = text;
			ibus_emojier_show_code_point_description (self, _tmp110_);
			_g_object_unref0 (widget);
			_g_free0 (text);
			_g_object_unref0 (grid);
			return;
		} else {
			const gchar* description = NULL;
			IBusEmojiData* _tmp111_;
			const gchar* _tmp112_;
			IBusEmojierEPaddedLabelBox* widget = NULL;
			const gchar* _tmp113_;
			gchar* _tmp114_;
			gchar* _tmp115_;
			IBusEmojierEPaddedLabelBox* _tmp116_;
			IBusEmojierEPaddedLabelBox* _tmp117_;
			GtkBox* _tmp118_;
			IBusEmojierEPaddedLabelBox* _tmp119_;
			IBusEmojierEPaddedLabelBox* _tmp120_;
			_tmp111_ = data;
			_tmp112_ = ibus_emoji_data_get_description (_tmp111_);
			description = _tmp112_;
			_tmp113_ = description;
			_tmp114_ = g_strdup_printf (_ ("Description: %s"), _tmp113_);
			_tmp115_ = _tmp114_;
			_tmp116_ = ibus_emojier_epadded_label_box_new (_tmp115_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE);
			g_object_ref_sink (_tmp116_);
			_tmp117_ = _tmp116_;
			_g_free0 (_tmp115_);
			widget = _tmp117_;
			_tmp118_ = self->priv->m_vbox;
			_tmp119_ = widget;
			gtk_container_add ((GtkContainer*) _tmp118_, (GtkWidget*) _tmp119_);
			_tmp120_ = widget;
			gtk_widget_show_all ((GtkWidget*) _tmp120_);
			_g_object_unref0 (widget);
		}
		_tmp121_ = data;
		_tmp122_ = ibus_emoji_data_get_annotations (_tmp121_);
		annotations = _tmp122_;
		_tmp123_ = g_string_new ("");
		buff = _tmp123_;
		i = 0;
		_tmp124_ = annotations;
		{
			GSList* annotation_collection = NULL;
			GSList* annotation_it = NULL;
			annotation_collection = _tmp124_;
			for (annotation_it = annotation_collection; annotation_it != NULL; annotation_it = annotation_it->next) {
				const gchar* annotation = NULL;
				annotation = (const gchar*) annotation_it->data;
				{
					gint _tmp125_;
					GString* _tmp130_;
					const gchar* _tmp131_;
					gint _tmp132_;
					_tmp125_ = i;
					i = _tmp125_ + 1;
					if (_tmp125_ == 0) {
						GString* _tmp126_;
						const gchar* _tmp127_;
						_tmp126_ = buff;
						_tmp127_ = annotation;
						g_string_append_printf (_tmp126_, _ ("Annotations: %s"), _tmp127_);
					} else {
						GString* _tmp128_;
						const gchar* _tmp129_;
						_tmp128_ = buff;
						_tmp129_ = annotation;
						g_string_append_printf (_tmp128_, " | %s", _tmp129_);
					}
					_tmp130_ = buff;
					_tmp131_ = _tmp130_->str;
					_tmp132_ = g_utf8_strlen (_tmp131_, (gssize) -1);
					if (_tmp132_ > 30) {
						IBusEmojierEPaddedLabelBox* widget = NULL;
						GString* _tmp133_;
						const gchar* _tmp134_;
						IBusEmojierEPaddedLabelBox* _tmp135_;
						GtkBox* _tmp136_;
						IBusEmojierEPaddedLabelBox* _tmp137_;
						IBusEmojierEPaddedLabelBox* _tmp138_;
						GString* _tmp139_;
						_tmp133_ = buff;
						_tmp134_ = _tmp133_->str;
						_tmp135_ = ibus_emojier_epadded_label_box_new (_tmp134_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE);
						g_object_ref_sink (_tmp135_);
						widget = _tmp135_;
						_tmp136_ = self->priv->m_vbox;
						_tmp137_ = widget;
						gtk_container_add ((GtkContainer*) _tmp136_, (GtkWidget*) _tmp137_);
						_tmp138_ = widget;
						gtk_widget_show_all ((GtkWidget*) _tmp138_);
						_tmp139_ = buff;
						g_string_erase (_tmp139_, (gssize) 0, (gssize) -1);
						_g_object_unref0 (widget);
					}
				}
			}
		}
		_tmp140_ = buff;
		_tmp141_ = _tmp140_->str;
		if (g_strcmp0 (_tmp141_, "") != 0) {
			IBusEmojierEPaddedLabelBox* widget = NULL;
			GString* _tmp142_;
			const gchar* _tmp143_;
			IBusEmojierEPaddedLabelBox* _tmp144_;
			GtkBox* _tmp145_;
			IBusEmojierEPaddedLabelBox* _tmp146_;
			IBusEmojierEPaddedLabelBox* _tmp147_;
			_tmp142_ = buff;
			_tmp143_ = _tmp142_->str;
			_tmp144_ = ibus_emojier_epadded_label_box_new (_tmp143_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE);
			g_object_ref_sink (_tmp144_);
			widget = _tmp144_;
			_tmp145_ = self->priv->m_vbox;
			_tmp146_ = widget;
			gtk_container_add ((GtkContainer*) _tmp145_, (GtkWidget*) _tmp146_);
			_tmp147_ = widget;
			gtk_widget_show_all ((GtkWidget*) _tmp147_);
			_g_object_unref0 (widget);
		}
		_tmp148_ = text;
		ibus_emojier_show_code_point_description (self, _tmp148_);
		_g_string_free0 (buff);
		_g_free0 (text);
	}
	_g_object_unref0 (grid);
}


static void ibus_emojier_hide_candidate_panel (IBusEmojier* self) {
	GMainLoop* _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	self->priv->m_enter_notify_enable = TRUE;
	self->priv->m_candidate_panel_is_visible = FALSE;
	_tmp0_ = self->priv->m_loop;
	_tmp1_ = g_main_loop_is_running (_tmp0_);
	if (_tmp1_) {
		ibus_emojier_show_category_list (self);
	}
}


static gboolean __lambda24_ (IBusEmojier* self) {
	gboolean result = FALSE;
	self->priv->m_enter_notify_enable = TRUE;
	result = FALSE;
	return result;
}


static gboolean ___lambda24__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda24_ ((IBusEmojier*) self);
	return result;
}


static void ibus_emojier_enter_notify_disable_with_timer (IBusEmojier* self) {
	guint _tmp0_;
	guint _tmp2_;
	g_return_if_fail (self != NULL);
	self->priv->m_enter_notify_enable = FALSE;
	_tmp0_ = self->priv->m_entry_notify_disable_id;
	if (_tmp0_ > ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->m_entry_notify_disable_id;
		g_source_remove (_tmp1_);
	}
	_tmp2_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, ___lambda24__gsource_func, g_object_ref (self), g_object_unref);
	self->priv->m_entry_notify_show_id = _tmp2_;
}


static void ibus_emojier_candidate_panel_select_index (IBusEmojier* self, guint index) {
	gchar* text = NULL;
	IBusLookupTable* _tmp0_;
	guint _tmp1_;
	IBusText* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	GSList* emojis = NULL;
	GHashTable* _tmp5_;
	const gchar* _tmp6_;
	gconstpointer _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp10_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_lookup_table;
	_tmp1_ = index;
	_tmp2_ = ibus_lookup_table_get_candidate (_tmp0_, _tmp1_);
	_tmp3_ = _tmp2_->text;
	_tmp4_ = g_strdup (_tmp3_);
	text = _tmp4_;
	_tmp5_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
	_tmp6_ = text;
	_tmp7_ = g_hash_table_lookup (_tmp5_, _tmp6_);
	emojis = (GSList*) _tmp7_;
	_tmp10_ = ibus_emojier_m_show_emoji_variant;
	if (_tmp10_) {
		GSList* _tmp11_;
		_tmp11_ = emojis;
		_tmp9_ = _tmp11_ != NULL;
	} else {
		_tmp9_ = FALSE;
	}
	if (_tmp9_) {
		gint _tmp12_;
		_tmp12_ = self->priv->m_backward_index;
		_tmp8_ = _tmp12_ < 0;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		GSList* _tmp13_;
		_tmp13_ = emojis;
		ibus_emojier_show_emoji_variants (self, _tmp13_);
	} else {
		const gchar* _tmp14_;
		gchar* _tmp15_;
		GMainLoop* _tmp16_;
		_tmp14_ = text;
		_tmp15_ = g_strdup (_tmp14_);
		_g_free0 (self->priv->m_result);
		self->priv->m_result = _tmp15_;
		_tmp16_ = self->priv->m_loop;
		g_main_loop_quit (_tmp16_);
		ibus_emojier_hide_candidate_panel (self);
	}
	_g_free0 (text);
}


static void ibus_emojier_candidate_panel_cursor_down (IBusEmojier* self) {
	guint ncandidates = 0U;
	IBusLookupTable* _tmp0_;
	guint _tmp1_;
	guint cursor = 0U;
	IBusLookupTable* _tmp2_;
	guint _tmp3_;
	guint _tmp4_;
	guint _tmp5_;
	g_return_if_fail (self != NULL);
	ibus_emojier_enter_notify_disable_with_timer (self);
	_tmp0_ = self->priv->m_lookup_table;
	_tmp1_ = ibus_lookup_table_get_number_of_candidates (_tmp0_);
	ncandidates = _tmp1_;
	_tmp2_ = self->priv->m_lookup_table;
	_tmp3_ = ibus_lookup_table_get_cursor_pos (_tmp2_);
	cursor = _tmp3_;
	_tmp4_ = cursor;
	_tmp5_ = ncandidates;
	if ((_tmp4_ + IBUS_EMOJIER_EMOJI_GRID_PAGE) < _tmp5_) {
		IBusLookupTable* _tmp6_;
		guint _tmp7_;
		_tmp6_ = self->priv->m_lookup_table;
		_tmp7_ = cursor;
		ibus_lookup_table_set_cursor_pos (_tmp6_, _tmp7_ + IBUS_EMOJIER_EMOJI_GRID_PAGE);
	} else {
		guint _tmp8_;
		guint _tmp9_;
		_tmp8_ = cursor;
		_tmp9_ = ncandidates;
		if ((_tmp8_ % IBUS_EMOJIER_EMOJI_GRID_PAGE) < _tmp9_) {
			IBusLookupTable* _tmp10_;
			guint _tmp11_;
			_tmp10_ = self->priv->m_lookup_table;
			_tmp11_ = cursor;
			ibus_lookup_table_set_cursor_pos (_tmp10_, _tmp11_ % IBUS_EMOJIER_EMOJI_GRID_PAGE);
		} else {
			IBusLookupTable* _tmp12_;
			_tmp12_ = self->priv->m_lookup_table;
			ibus_lookup_table_set_cursor_pos (_tmp12_, (guint) 0);
		}
	}
	ibus_emojier_show_candidate_panel (self);
}


static void ibus_emojier_candidate_panel_cursor_up (IBusEmojier* self) {
	gint ncandidates = 0;
	IBusLookupTable* _tmp0_;
	guint _tmp1_;
	gint cursor = 0;
	IBusLookupTable* _tmp2_;
	guint _tmp3_;
	gint highest_pos = 0;
	gint _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	g_return_if_fail (self != NULL);
	ibus_emojier_enter_notify_disable_with_timer (self);
	_tmp0_ = self->priv->m_lookup_table;
	_tmp1_ = ibus_lookup_table_get_number_of_candidates (_tmp0_);
	ncandidates = (gint) _tmp1_;
	_tmp2_ = self->priv->m_lookup_table;
	_tmp3_ = ibus_lookup_table_get_cursor_pos (_tmp2_);
	cursor = (gint) _tmp3_;
	_tmp4_ = ncandidates;
	_tmp5_ = cursor;
	highest_pos = (((_tmp4_ - 1) / ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE)) * ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE)) + (_tmp5_ % ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE));
	_tmp6_ = cursor;
	if ((_tmp6_ - ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE)) >= 0) {
		IBusLookupTable* _tmp7_;
		gint _tmp8_;
		_tmp7_ = self->priv->m_lookup_table;
		_tmp8_ = cursor;
		ibus_lookup_table_set_cursor_pos (_tmp7_, (guint) (_tmp8_ - ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE)));
	} else {
		gint _tmp9_;
		gint _tmp10_;
		_tmp9_ = highest_pos;
		_tmp10_ = ncandidates;
		if (_tmp9_ < _tmp10_) {
			IBusLookupTable* _tmp11_;
			gint _tmp12_;
			_tmp11_ = self->priv->m_lookup_table;
			_tmp12_ = highest_pos;
			ibus_lookup_table_set_cursor_pos (_tmp11_, (guint) _tmp12_);
		} else {
			IBusLookupTable* _tmp13_;
			_tmp13_ = self->priv->m_lookup_table;
			ibus_lookup_table_set_cursor_pos (_tmp13_, (guint) 0);
		}
	}
	ibus_emojier_show_candidate_panel (self);
}


static void ibus_emojier_category_list_cursor_move (IBusEmojier* self, guint keyval) {
	GList* list = NULL;
	IBusEmojierEListBox* _tmp0_;
	GList* _tmp1_;
	guint _tmp2_;
	GtkAdjustment* adjustment = NULL;
	IBusEmojierEListBox* _tmp12_;
	GtkAdjustment* _tmp13_;
	GtkAdjustment* _tmp14_;
	IBusEmojierEScrolledWindow* _tmp15_;
	GtkAdjustment* _tmp16_;
	GtkAdjustment* _tmp17_;
	IBusEmojierEScrolledWindow* _tmp18_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_list_box;
	_tmp1_ = gtk_container_get_children ((GtkContainer*) _tmp0_);
	list = _tmp1_;
	_tmp2_ = keyval;
	if (_tmp2_ == ((guint) GDK_KEY_Down)) {
		gint _tmp3_;
		gint _tmp4_;
		GList* _tmp5_;
		guint _tmp6_;
		_tmp3_ = self->priv->m_category_active_index;
		self->priv->m_category_active_index = _tmp3_ + 1;
		_tmp4_ = self->priv->m_category_active_index;
		_tmp5_ = list;
		_tmp6_ = g_list_length (_tmp5_);
		self->priv->m_category_active_index = _tmp4_ % (((gint) _tmp6_) + 1);
	} else {
		guint _tmp7_;
		_tmp7_ = keyval;
		if (_tmp7_ == ((guint) GDK_KEY_Up)) {
			gint _tmp8_;
			gint _tmp9_;
			_tmp8_ = self->priv->m_category_active_index;
			self->priv->m_category_active_index = _tmp8_ - 1;
			_tmp9_ = self->priv->m_category_active_index;
			if (_tmp9_ < 0) {
				GList* _tmp10_;
				guint _tmp11_;
				_tmp10_ = list;
				_tmp11_ = g_list_length (_tmp10_);
				self->priv->m_category_active_index = (gint) _tmp11_;
			}
		}
	}
	_tmp12_ = self->priv->m_list_box;
	_tmp13_ = gtk_list_box_get_adjustment ((GtkListBox*) _tmp12_);
	_tmp14_ = _g_object_ref0 (_tmp13_);
	adjustment = _tmp14_;
	_tmp15_ = self->priv->m_scrolled_window;
	_tmp16_ = gtk_adjustment_new ((gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 0);
	g_object_ref_sink (_tmp16_);
	_tmp17_ = _tmp16_;
	gtk_scrolled_window_set_hadjustment ((GtkScrolledWindow*) _tmp15_, _tmp17_);
	_g_object_unref0 (_tmp17_);
	_tmp18_ = self->priv->m_scrolled_window;
	gtk_scrolled_window_set_vadjustment ((GtkScrolledWindow*) _tmp18_, adjustment);
	ibus_emojier_show_category_list (self);
	_g_object_unref0 (adjustment);
	_g_list_free0 (list);
}


static gboolean ibus_emojier_key_press_cursor_horizontal (IBusEmojier* self, guint keyval, guint modifiers) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	guint _tmp1_;
	guint ncandidates = 0U;
	IBusLookupTable* _tmp3_;
	guint _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = keyval;
	if (_tmp1_ == ((guint) GDK_KEY_Left)) {
		_tmp0_ = TRUE;
	} else {
		guint _tmp2_;
		_tmp2_ = keyval;
		_tmp0_ = _tmp2_ == ((guint) GDK_KEY_Right);
	}
	_vala_assert (_tmp0_, "keyval == Gdk.Key.Left || keyval == Gdk.Key.Right");
	_tmp3_ = self->priv->m_lookup_table;
	_tmp4_ = ibus_lookup_table_get_number_of_candidates (_tmp3_);
	ncandidates = _tmp4_;
	_tmp6_ = self->priv->m_candidate_panel_is_visible;
	if (_tmp6_) {
		guint _tmp7_;
		_tmp7_ = ncandidates;
		_tmp5_ = _tmp7_ > ((guint) 1);
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		guint _tmp8_;
		ibus_emojier_enter_notify_disable_with_timer (self);
		_tmp8_ = keyval;
		if (_tmp8_ == ((guint) GDK_KEY_Left)) {
			IBusLookupTable* _tmp9_;
			_tmp9_ = self->priv->m_lookup_table;
			ibus_lookup_table_cursor_up (_tmp9_);
		} else {
			guint _tmp10_;
			_tmp10_ = keyval;
			if (_tmp10_ == ((guint) GDK_KEY_Right)) {
				IBusLookupTable* _tmp11_;
				_tmp11_ = self->priv->m_lookup_table;
				ibus_lookup_table_cursor_down (_tmp11_);
			}
		}
		ibus_emojier_show_candidate_panel (self);
	} else {
		IBusEmojierEEntry* _tmp12_;
		const gchar* _tmp13_;
		gint _tmp14_;
		gint _tmp15_;
		_tmp12_ = self->priv->m_entry;
		_tmp13_ = gtk_entry_get_text ((GtkEntry*) _tmp12_);
		_tmp14_ = strlen (_tmp13_);
		_tmp15_ = _tmp14_;
		if (_tmp15_ > 0) {
			gint step = 0;
			guint _tmp16_;
			gboolean _tmp18_ = FALSE;
			guint _tmp19_;
			IBusEmojierEEntry* _tmp20_;
			gint _tmp21_;
			step = 0;
			_tmp16_ = keyval;
			if (_tmp16_ == ((guint) GDK_KEY_Left)) {
				step = -1;
			} else {
				guint _tmp17_;
				_tmp17_ = keyval;
				if (_tmp17_ == ((guint) GDK_KEY_Right)) {
					step = 1;
				}
			}
			_tmp19_ = modifiers;
			if ((_tmp19_ & GDK_SHIFT_MASK) != ((guint) 0)) {
				_tmp18_ = TRUE;
			} else {
				_tmp18_ = FALSE;
			}
			_tmp20_ = self->priv->m_entry;
			_tmp21_ = step;
			g_signal_emit_by_name (_tmp20_, "move-cursor", GTK_MOVEMENT_VISUAL_POSITIONS, _tmp21_, _tmp18_, NULL);
		} else {
			guint _tmp22_;
			guint _tmp24_;
			_tmp22_ = keyval;
			if (_tmp22_ == ((guint) GDK_KEY_Left)) {
				keyval = (guint) GDK_KEY_Up;
			} else {
				guint _tmp23_;
				_tmp23_ = keyval;
				if (_tmp23_ == ((guint) GDK_KEY_Right)) {
					keyval = (guint) GDK_KEY_Down;
				}
			}
			_tmp24_ = keyval;
			ibus_emojier_category_list_cursor_move (self, _tmp24_);
		}
	}
	result = TRUE;
	return result;
}


static gboolean ibus_emojier_key_press_cursor_vertical (IBusEmojier* self, guint keyval) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	guint _tmp1_;
	guint ncandidates = 0U;
	IBusLookupTable* _tmp3_;
	guint _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = keyval;
	if (_tmp1_ == ((guint) GDK_KEY_Down)) {
		_tmp0_ = TRUE;
	} else {
		guint _tmp2_;
		_tmp2_ = keyval;
		_tmp0_ = _tmp2_ == ((guint) GDK_KEY_Up);
	}
	_vala_assert (_tmp0_, "keyval == Gdk.Key.Down || keyval == Gdk.Key.Up");
	_tmp3_ = self->priv->m_lookup_table;
	_tmp4_ = ibus_lookup_table_get_number_of_candidates (_tmp3_);
	ncandidates = _tmp4_;
	_tmp6_ = self->priv->m_candidate_panel_is_visible;
	if (_tmp6_) {
		guint _tmp7_;
		_tmp7_ = ncandidates;
		_tmp5_ = _tmp7_ > ((guint) 1);
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		guint _tmp8_;
		_tmp8_ = keyval;
		if (_tmp8_ == ((guint) GDK_KEY_Down)) {
			ibus_emojier_candidate_panel_cursor_down (self);
		} else {
			guint _tmp9_;
			_tmp9_ = keyval;
			if (_tmp9_ == ((guint) GDK_KEY_Up)) {
				ibus_emojier_candidate_panel_cursor_up (self);
			}
		}
	} else {
		guint _tmp10_;
		_tmp10_ = keyval;
		ibus_emojier_category_list_cursor_move (self, _tmp10_);
	}
	result = TRUE;
	return result;
}


static gboolean ibus_emojier_key_press_cursor_home_end (IBusEmojier* self, guint keyval, guint modifiers) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	guint _tmp1_;
	guint ncandidates = 0U;
	IBusLookupTable* _tmp3_;
	guint _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	IBusEmojierEEntry* _tmp13_;
	const gchar* _tmp14_;
	gint _tmp15_;
	gint _tmp16_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = keyval;
	if (_tmp1_ == ((guint) GDK_KEY_Home)) {
		_tmp0_ = TRUE;
	} else {
		guint _tmp2_;
		_tmp2_ = keyval;
		_tmp0_ = _tmp2_ == ((guint) GDK_KEY_End);
	}
	_vala_assert (_tmp0_, "keyval == Gdk.Key.Home || keyval == Gdk.Key.End");
	_tmp3_ = self->priv->m_lookup_table;
	_tmp4_ = ibus_lookup_table_get_number_of_candidates (_tmp3_);
	ncandidates = _tmp4_;
	_tmp6_ = self->priv->m_candidate_panel_is_visible;
	if (_tmp6_) {
		guint _tmp7_;
		_tmp7_ = ncandidates;
		_tmp5_ = _tmp7_ > ((guint) 1);
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		guint _tmp8_;
		ibus_emojier_enter_notify_disable_with_timer (self);
		_tmp8_ = keyval;
		if (_tmp8_ == ((guint) GDK_KEY_Home)) {
			IBusLookupTable* _tmp9_;
			_tmp9_ = self->priv->m_lookup_table;
			ibus_lookup_table_set_cursor_pos (_tmp9_, (guint) 0);
		} else {
			guint _tmp10_;
			_tmp10_ = keyval;
			if (_tmp10_ == ((guint) GDK_KEY_End)) {
				IBusLookupTable* _tmp11_;
				guint _tmp12_;
				_tmp11_ = self->priv->m_lookup_table;
				_tmp12_ = ncandidates;
				ibus_lookup_table_set_cursor_pos (_tmp11_, _tmp12_ - 1);
			}
		}
		ibus_emojier_show_candidate_panel (self);
		result = TRUE;
		return result;
	}
	_tmp13_ = self->priv->m_entry;
	_tmp14_ = gtk_entry_get_text ((GtkEntry*) _tmp13_);
	_tmp15_ = strlen (_tmp14_);
	_tmp16_ = _tmp15_;
	if (_tmp16_ > 0) {
		gint step = 0;
		guint _tmp17_;
		gboolean _tmp19_ = FALSE;
		guint _tmp20_;
		IBusEmojierEEntry* _tmp21_;
		gint _tmp22_;
		step = 0;
		_tmp17_ = keyval;
		if (_tmp17_ == ((guint) GDK_KEY_Home)) {
			step = -1;
		} else {
			guint _tmp18_;
			_tmp18_ = keyval;
			if (_tmp18_ == ((guint) GDK_KEY_End)) {
				step = 1;
			}
		}
		_tmp20_ = modifiers;
		if ((_tmp20_ & GDK_SHIFT_MASK) != ((guint) 0)) {
			_tmp19_ = TRUE;
		} else {
			_tmp19_ = FALSE;
		}
		_tmp21_ = self->priv->m_entry;
		_tmp22_ = step;
		g_signal_emit_by_name (_tmp21_, "move-cursor", GTK_MOVEMENT_DISPLAY_LINE_ENDS, _tmp22_, _tmp19_, NULL);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean ibus_emojier_key_press_escape (IBusEmojier* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	IBusEmojierEEntry* _tmp10_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->priv->m_backward_index;
	if (_tmp1_ >= 0) {
		const gchar* _tmp2_;
		_tmp2_ = self->priv->m_backward;
		_tmp0_ = _tmp2_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		const gchar* _tmp3_;
		_tmp3_ = self->priv->m_backward;
		ibus_emojier_show_emoji_for_category (self, _tmp3_);
		result = TRUE;
		return result;
	} else {
		gboolean _tmp4_;
		_tmp4_ = self->priv->m_candidate_panel_is_visible;
		if (_tmp4_) {
			ibus_emojier_hide_candidate_panel (self);
			result = TRUE;
			return result;
		} else {
			IBusEmojierEEntry* _tmp5_;
			const gchar* _tmp6_;
			gint _tmp7_;
			gint _tmp8_;
			_tmp5_ = self->priv->m_entry;
			_tmp6_ = gtk_entry_get_text ((GtkEntry*) _tmp5_);
			_tmp7_ = strlen (_tmp6_);
			_tmp8_ = _tmp7_;
			if (_tmp8_ == 0) {
				GMainLoop* _tmp9_;
				_tmp9_ = self->priv->m_loop;
				g_main_loop_quit (_tmp9_);
				ibus_emojier_hide_candidate_panel (self);
				result = TRUE;
				return result;
			}
		}
	}
	_tmp10_ = self->priv->m_entry;
	gtk_editable_delete_text ((GtkEditable*) _tmp10_, 0, -1);
	result = TRUE;
	return result;
}


static gboolean ibus_emojier_key_press_enter (IBusEmojier* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->m_candidate_panel_is_visible;
	if (_tmp0_) {
		guint index = 0U;
		IBusLookupTable* _tmp1_;
		guint _tmp2_;
		guint _tmp3_;
		_tmp1_ = self->priv->m_lookup_table;
		_tmp2_ = ibus_lookup_table_get_cursor_pos (_tmp1_);
		index = _tmp2_;
		_tmp3_ = index;
		ibus_emojier_candidate_panel_select_index (self, _tmp3_);
	} else {
		gint _tmp4_;
		_tmp4_ = self->priv->m_category_active_index;
		if (_tmp4_ > 0) {
			GtkListBoxRow* gtkrow = NULL;
			IBusEmojierEListBox* _tmp5_;
			GtkListBoxRow* _tmp6_;
			GtkListBoxRow* _tmp7_;
			IBusEmojierEBoxRow* row = NULL;
			GtkListBoxRow* _tmp8_;
			IBusEmojierEBoxRow* _tmp9_;
			IBusEmojierEBoxRow* _tmp10_;
			const gchar* _tmp11_;
			const gchar* _tmp12_;
			_tmp5_ = self->priv->m_list_box;
			_tmp6_ = gtk_list_box_get_selected_row ((GtkListBox*) _tmp5_);
			_tmp7_ = _g_object_ref0 (_tmp6_);
			gtkrow = _tmp7_;
			_tmp8_ = gtkrow;
			_tmp9_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp8_, IBUS_EMOJIER_TYPE_EBOX_ROW) ? ((IBusEmojierEBoxRow*) _tmp8_) : NULL);
			row = _tmp9_;
			_tmp10_ = row;
			_tmp11_ = ibus_emojier_ebox_row_get_text (_tmp10_);
			_tmp12_ = _tmp11_;
			ibus_emojier_show_emoji_for_category (self, _tmp12_);
			_g_object_unref0 (row);
			_g_object_unref0 (gtkrow);
		}
	}
	result = TRUE;
	return result;
}


static void ibus_emojier_entry_enter_keyval (IBusEmojier* self, guint keyval) {
	gunichar ch = 0U;
	guint _tmp0_;
	gunichar _tmp1_;
	gunichar _tmp2_;
	gboolean _tmp3_;
	gchar* str = NULL;
	gunichar _tmp4_;
	gchar* _tmp5_;
	IBusEmojierEEntry* _tmp6_;
	gboolean _tmp7_;
	gint pos = 0;
	IBusEmojierEEntry* _tmp19_;
	gint _tmp20_;
	IBusEmojierEEntry* _tmp21_;
	const gchar* _tmp22_;
	IBusEmojierEEntry* _tmp23_;
	gint _tmp24_;
	g_return_if_fail (self != NULL);
	_tmp0_ = keyval;
	_tmp1_ = ibus_keyval_to_unicode (_tmp0_);
	ch = _tmp1_;
	_tmp2_ = ch;
	_tmp3_ = g_unichar_iscntrl (_tmp2_);
	if (_tmp3_) {
		return;
	}
	_tmp4_ = ch;
	_tmp5_ = g_unichar_to_string (_tmp4_);
	str = _tmp5_;
	_tmp6_ = self->priv->m_entry;
	_tmp7_ = gtk_editable_get_selection_bounds ((GtkEditable*) _tmp6_, NULL, NULL);
	if (_tmp7_) {
		IBusEmojierEEntry* _tmp8_;
		_tmp8_ = self->priv->m_entry;
		gtk_editable_delete_selection ((GtkEditable*) _tmp8_);
	} else {
		IBusEmojierEEntry* _tmp9_;
		gboolean _tmp10_;
		_tmp9_ = self->priv->m_entry;
		_tmp10_ = gtk_entry_get_overwrite_mode ((GtkEntry*) _tmp9_);
		if (_tmp10_) {
			guint text_length = 0U;
			IBusEmojierEEntry* _tmp11_;
			GtkEntryBuffer* _tmp12_;
			guint _tmp13_;
			IBusEmojierEEntry* _tmp14_;
			gint _tmp15_;
			gint _tmp16_;
			guint _tmp17_;
			_tmp11_ = self->priv->m_entry;
			_tmp12_ = gtk_entry_get_buffer ((GtkEntry*) _tmp11_);
			_tmp13_ = gtk_entry_buffer_get_length (_tmp12_);
			text_length = _tmp13_;
			_tmp14_ = self->priv->m_entry;
			g_object_get ((GtkEntry*) _tmp14_, "cursor-position", &_tmp15_, NULL);
			_tmp16_ = _tmp15_;
			_tmp17_ = text_length;
			if (((guint) _tmp16_) < _tmp17_) {
				IBusEmojierEEntry* _tmp18_;
				_tmp18_ = self->priv->m_entry;
				g_signal_emit_by_name ((GtkEntry*) _tmp18_, "delete-from-cursor", GTK_DELETE_CHARS, 1);
			}
		}
	}
	_tmp19_ = self->priv->m_entry;
	_tmp20_ = gtk_editable_get_position ((GtkEditable*) _tmp19_);
	pos = _tmp20_;
	_tmp21_ = self->priv->m_entry;
	_tmp22_ = str;
	gtk_editable_insert_text ((GtkEditable*) _tmp21_, _tmp22_, -1, &pos);
	_tmp23_ = self->priv->m_entry;
	_tmp24_ = pos;
	gtk_editable_set_position ((GtkEditable*) _tmp23_, _tmp24_);
	_g_free0 (str);
}


static void ibus_emojier_check_action_variant_cb (IBusEmojier* self, GSimpleAction* action, GVariant* parameter) {
	GSimpleAction* _tmp0_;
	GVariant* _tmp1_;
	GVariant* _tmp2_;
	gboolean _tmp3_;
	GSimpleAction* _tmp4_;
	gboolean _tmp5_;
	GVariant* _tmp6_;
	GVariant* _tmp7_;
	gboolean _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = action;
	_tmp1_ = g_action_get_state ((GAction*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_variant_get_boolean (_tmp2_);
	ibus_emojier_m_show_emoji_variant = !_tmp3_;
	_g_variant_unref0 (_tmp2_);
	_tmp4_ = action;
	_tmp5_ = ibus_emojier_m_show_emoji_variant;
	_tmp6_ = g_variant_new_boolean (_tmp5_);
	g_variant_ref_sink (_tmp6_);
	_tmp7_ = _tmp6_;
	g_simple_action_set_state (_tmp4_, _tmp7_);
	_g_variant_unref0 (_tmp7_);
	_tmp8_ = self->priv->m_candidate_panel_is_visible;
	if (_tmp8_) {
		ibus_emojier_show_candidate_panel (self);
	}
}


void ibus_emojier_update_favorite_emoji_dict (void) {
	gboolean _tmp0_ = FALSE;
	GHashTable* _tmp1_;
	_tmp1_ = ibus_emojier_m_emoji_to_data_dict;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		GHashTable* _tmp2_;
		_tmp2_ = ibus_emojier_m_annotation_to_emojis_dict;
		_tmp0_ = _tmp2_ == NULL;
	}
	if (_tmp0_) {
		return;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_;
				gchar** _tmp6_;
				gint _tmp6__length1;
				gchar* favorite = NULL;
				gchar** _tmp7_;
				gint _tmp7__length1;
				gint _tmp8_;
				const gchar* _tmp9_;
				gchar* _tmp10_;
				gchar* annotation = NULL;
				gchar* _tmp11_;
				gint _tmp12_;
				gchar** _tmp13_;
				gint _tmp13__length1;
				const gchar* _tmp18_;
				IBusEmojiData* data = NULL;
				GHashTable* _tmp19_;
				const gchar* _tmp20_;
				gconstpointer _tmp21_;
				IBusEmojiData* _tmp22_;
				GSList* emojis = NULL;
				GHashTable* _tmp52_;
				const gchar* _tmp53_;
				gconstpointer _tmp54_;
				GSList* _tmp55_;
				const gchar* _tmp56_;
				GCompareFunc _tmp57_;
				GSList* _tmp58_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = ibus_emojier_m_favorites;
				_tmp6__length1 = ibus_emojier_m_favorites_length1;
				if (!(_tmp5_ < _tmp6__length1)) {
					break;
				}
				_tmp7_ = ibus_emojier_m_favorites;
				_tmp7__length1 = ibus_emojier_m_favorites_length1;
				_tmp8_ = i;
				_tmp9_ = _tmp7_[_tmp8_];
				_tmp10_ = g_strdup (_tmp9_);
				favorite = _tmp10_;
				_tmp11_ = g_strdup ("");
				annotation = _tmp11_;
				_tmp12_ = i;
				_tmp13_ = ibus_emojier_m_favorite_annotations;
				_tmp13__length1 = ibus_emojier_m_favorite_annotations_length1;
				if (_tmp12_ < _tmp13__length1) {
					gchar** _tmp14_;
					gint _tmp14__length1;
					gint _tmp15_;
					const gchar* _tmp16_;
					gchar* _tmp17_;
					_tmp14_ = ibus_emojier_m_favorite_annotations;
					_tmp14__length1 = ibus_emojier_m_favorite_annotations_length1;
					_tmp15_ = i;
					_tmp16_ = _tmp14_[_tmp15_];
					_tmp17_ = g_strdup (_tmp16_);
					_g_free0 (annotation);
					annotation = _tmp17_;
				}
				_tmp18_ = annotation;
				if (g_strcmp0 (_tmp18_, "") == 0) {
					_g_free0 (annotation);
					_g_free0 (favorite);
					continue;
				}
				_tmp19_ = ibus_emojier_m_emoji_to_data_dict;
				_tmp20_ = favorite;
				_tmp21_ = g_hash_table_lookup (_tmp19_, _tmp20_);
				data = (IBusEmojiData*) _tmp21_;
				_tmp22_ = data;
				if (_tmp22_ == NULL) {
					GSList* new_annotations = NULL;
					const gchar* _tmp23_;
					gchar* _tmp24_;
					IBusEmojiData* new_data = NULL;
					const gchar* _tmp25_;
					gchar* _tmp26_;
					gchar* _tmp27_;
					GSList* _tmp28_;
					const gchar* _tmp29_;
					gchar* _tmp30_;
					gchar* _tmp31_;
					GObject* _tmp32_;
					GObject* _tmp33_;
					IBusEmojiData* _tmp34_;
					IBusEmojiData* _tmp35_;
					GHashTable* _tmp36_;
					const gchar* _tmp37_;
					gchar* _tmp38_;
					IBusEmojiData* _tmp39_;
					IBusEmojiData* _tmp40_;
					new_annotations = NULL;
					_tmp23_ = annotation;
					_tmp24_ = g_strdup (_tmp23_);
					new_annotations = g_slist_append (new_annotations, _tmp24_);
					_tmp25_ = favorite;
					_tmp26_ = g_strdup (_tmp25_);
					_tmp27_ = _tmp26_;
					_tmp28_ = new_annotations;
					_tmp29_ = annotation;
					_tmp30_ = g_strdup (_tmp29_);
					_tmp31_ = _tmp30_;
					_tmp32_ = g_object_new (ibus_emoji_data_get_type (), "emoji", _tmp27_, "annotations", _tmp28_, "description", _tmp31_, NULL);
					_tmp33_ = G_IS_INITIALLY_UNOWNED (_tmp32_) ? g_object_ref_sink (_tmp32_) : _tmp32_;
					_tmp34_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp33_, ibus_emoji_data_get_type ()) ? ((IBusEmojiData*) _tmp33_) : NULL;
					if (_tmp34_ == NULL) {
						_g_object_unref0 (_tmp33_);
					}
					_tmp35_ = _tmp34_;
					_g_free0 (_tmp31_);
					_g_free0 (_tmp27_);
					new_data = _tmp35_;
					_tmp36_ = ibus_emojier_m_emoji_to_data_dict;
					_tmp37_ = favorite;
					_tmp38_ = g_strdup (_tmp37_);
					_tmp39_ = new_data;
					_tmp40_ = _g_object_ref0 (_tmp39_);
					g_hash_table_insert (_tmp36_, _tmp38_, _tmp40_);
					_g_object_unref0 (new_data);
					__g_slist_free__g_free0_0 (new_annotations);
				} else {
					GSList* annotations = NULL;
					IBusEmojiData* _tmp41_;
					GSList* _tmp42_;
					GSList* _tmp43_;
					const gchar* _tmp44_;
					GCompareFunc _tmp45_;
					GSList* _tmp46_;
					_tmp41_ = data;
					_tmp42_ = ibus_emoji_data_get_annotations (_tmp41_);
					annotations = _tmp42_;
					_tmp43_ = annotations;
					_tmp44_ = annotation;
					_tmp45_ = g_strcmp0;
					_tmp46_ = g_slist_find_custom (_tmp43_, _tmp44_, _tmp45_);
					if (_tmp46_ == NULL) {
						const gchar* _tmp47_;
						gchar* _tmp48_;
						IBusEmojiData* _tmp49_;
						GSList* _tmp50_;
						GSList* _tmp51_;
						_tmp47_ = annotation;
						_tmp48_ = g_strdup (_tmp47_);
						annotations = g_slist_append (annotations, _tmp48_);
						_tmp49_ = data;
						_tmp50_ = annotations;
						_tmp51_ = g_slist_copy (_tmp50_);
						ibus_emoji_data_set_annotations (_tmp49_, _tmp51_);
					}
				}
				_tmp52_ = ibus_emojier_m_annotation_to_emojis_dict;
				_tmp53_ = annotation;
				_tmp54_ = g_hash_table_lookup (_tmp52_, _tmp53_);
				emojis = (GSList*) _tmp54_;
				_tmp55_ = emojis;
				_tmp56_ = favorite;
				_tmp57_ = g_strcmp0;
				_tmp58_ = g_slist_find_custom (_tmp55_, _tmp56_, _tmp57_);
				if (_tmp58_ == NULL) {
					const gchar* _tmp59_;
					gchar* _tmp60_;
					GHashTable* _tmp61_;
					const gchar* _tmp62_;
					gchar* _tmp63_;
					GSList* _tmp64_;
					GSList* _tmp65_;
					_tmp59_ = favorite;
					_tmp60_ = g_strdup (_tmp59_);
					emojis = g_slist_append (emojis, _tmp60_);
					_tmp61_ = ibus_emojier_m_annotation_to_emojis_dict;
					_tmp62_ = annotation;
					_tmp63_ = g_strdup (_tmp62_);
					_tmp64_ = emojis;
					_tmp65_ = g_slist_copy (_tmp64_);
					g_hash_table_replace (_tmp61_, _tmp63_, _tmp65_);
				}
				_g_free0 (annotation);
				_g_free0 (favorite);
			}
		}
	}
}


static void _vala_GdkEvent_free (GdkEvent* self) {
	g_boxed_free (gdk_event_get_type (), self);
}


gchar* ibus_emojier_run (IBusEmojier* self, const gchar* input_context_path, GdkEvent* event) {
	gchar* result = NULL;
	GMainLoop* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	IBusEmojierEEntry* _tmp3_;
	IBusEmojierEEntry* _tmp4_;
	guint32 timestamp = 0U;
	GdkEvent* _tmp5_;
	guint32 _tmp6_;
	guint32 _tmp7_;
	GdkDevice* pointer = NULL;
	GdkSeat* seat = NULL;
	GdkEvent* _tmp8_;
	GdkSeat* _tmp9_;
	GdkSeat* _tmp10_;
	GdkSeat* _tmp11_;
	GdkSeat* _tmp17_;
	GdkDevice* _tmp18_;
	GdkDevice* _tmp19_;
	GdkDevice* _tmp20_;
	gdouble _tmp21_ = 0.0;
	gdouble _tmp22_ = 0.0;
	GMainLoop* _tmp23_;
	GMainLoop* _tmp24_;
	GdkEvent* fevent = NULL;
	GdkEvent* _tmp25_;
	GdkEvent* _tmp26_;
	GdkEventFocus* _tmp27_;
	GdkEventFocus* _tmp28_;
	GdkEvent* _tmp29_;
	GdkEventFocus* _tmp30_;
	GdkEventFocus* _tmp31_;
	GdkWindow* _tmp32_;
	IBusEmojierEEntry* _tmp33_;
	GdkEvent* _tmp34_;
	GdkEvent* _tmp35_;
	GdkEventFocus* _tmp36_;
	GdkEventFocus* _tmp37_;
	const gchar* _tmp39_;
	gchar* _tmp40_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (input_context_path != NULL, NULL);
	g_return_val_if_fail (event != NULL, NULL);
	_tmp0_ = self->priv->m_loop;
	_vala_assert (_tmp0_ == NULL, "m_loop == null");
	self->priv->m_is_running = TRUE;
	_tmp1_ = input_context_path;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->priv->m_input_context_path);
	self->priv->m_input_context_path = _tmp2_;
	self->priv->m_candidate_panel_is_visible = FALSE;
	_g_free0 (self->priv->m_result);
	self->priv->m_result = NULL;
	self->priv->m_enter_notify_enable = TRUE;
	gtk_window_resize ((GtkWindow*) self, 1, 1);
	_tmp3_ = self->priv->m_entry;
	gtk_entry_set_text ((GtkEntry*) _tmp3_, "");
	ibus_emojier_show_category_list (self);
	_tmp4_ = self->priv->m_entry;
	gtk_entry_set_activates_default ((GtkEntry*) _tmp4_, TRUE);
	gtk_widget_show_all ((GtkWidget*) self);
	_tmp5_ = event;
	_tmp6_ = gdk_event_get_time (_tmp5_);
	timestamp = _tmp6_;
	_tmp7_ = timestamp;
	gtk_window_present_with_time ((GtkWindow*) self, _tmp7_);
	_tmp8_ = event;
	_tmp9_ = gdk_event_get_seat (_tmp8_);
	_tmp10_ = _g_object_ref0 (_tmp9_);
	seat = _tmp10_;
	_tmp11_ = seat;
	if (_tmp11_ == NULL) {
		GdkDisplay* display = NULL;
		GdkDisplay* _tmp12_;
		GdkDisplay* _tmp13_;
		GdkDisplay* _tmp14_;
		GdkSeat* _tmp15_;
		GdkSeat* _tmp16_;
		_tmp12_ = gtk_widget_get_display ((GtkWidget*) self);
		_tmp13_ = _g_object_ref0 (_tmp12_);
		display = _tmp13_;
		_tmp14_ = display;
		_tmp15_ = gdk_display_get_default_seat (_tmp14_);
		_tmp16_ = _g_object_ref0 (_tmp15_);
		_g_object_unref0 (seat);
		seat = _tmp16_;
		_g_object_unref0 (display);
	}
	_tmp17_ = seat;
	_tmp18_ = gdk_seat_get_pointer (_tmp17_);
	_tmp19_ = _g_object_ref0 (_tmp18_);
	_g_object_unref0 (pointer);
	pointer = _tmp19_;
	_tmp20_ = pointer;
	gdk_device_get_position_double (_tmp20_, NULL, &_tmp21_, &_tmp22_);
	ibus_emojier_m_mouse_x = _tmp21_;
	ibus_emojier_m_mouse_y = _tmp22_;
	_tmp23_ = g_main_loop_new (NULL, FALSE);
	_g_main_loop_unref0 (self->priv->m_loop);
	self->priv->m_loop = _tmp23_;
	_tmp24_ = self->priv->m_loop;
	g_main_loop_run (_tmp24_);
	_g_main_loop_unref0 (self->priv->m_loop);
	self->priv->m_loop = NULL;
	_tmp25_ = gdk_event_new (GDK_FOCUS_CHANGE);
	fevent = _tmp25_;
	_tmp26_ = fevent;
	_tmp27_ = (GdkEventFocus *) (_tmp26_);
	_tmp28_ = _tmp27_;
	_tmp28_->in = (gint16) 0;
	_tmp29_ = fevent;
	_tmp30_ = (GdkEventFocus *) (_tmp29_);
	_tmp31_ = _tmp30_;
	_tmp32_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp31_->window = _tmp32_;
	_tmp33_ = self->priv->m_entry;
	_tmp34_ = fevent;
	gtk_widget_send_focus_change ((GtkWidget*) _tmp33_, _tmp34_);
	_tmp35_ = fevent;
	_tmp36_ = (GdkEventFocus *) (_tmp35_);
	_tmp37_ = _tmp36_;
	_tmp37_->window = NULL;
	gtk_widget_hide ((GtkWidget*) self);
	while (TRUE) {
		gboolean _tmp38_;
		_tmp38_ = gtk_events_pending ();
		if (!_tmp38_) {
			break;
		}
		gtk_main_iteration ();
	}
	self->priv->m_is_running = FALSE;
	_tmp39_ = self->priv->m_result;
	_tmp40_ = g_strdup (_tmp39_);
	result = _tmp40_;
	__vala_GdkEvent_free0 (fevent);
	_g_object_unref0 (seat);
	_g_object_unref0 (pointer);
	return result;
}


static void ibus_emojier_real_show (GtkWidget* base) {
	IBusEmojier * self;
	self = (IBusEmojier*) base;
	GTK_WIDGET_CLASS (ibus_emojier_parent_class)->show ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_window_get_type (), GtkApplicationWindow));
	gtk_window_set_focus_visible ((GtkWindow*) self, TRUE);
}


static gboolean ibus_emojier_real_key_press_event (GtkWidget* base, GdkEventKey* event) {
	IBusEmojier * self;
	gboolean result = FALSE;
	guint keyval = 0U;
	GdkEventKey* _tmp0_;
	guint _tmp1_;
	guint modifiers = 0U;
	GdkEventKey* _tmp2_;
	GdkModifierType _tmp3_;
	guint _tmp4_;
	guint _tmp45_;
	guint _tmp88_;
	self = (IBusEmojier*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = event;
	_tmp1_ = _tmp0_->keyval;
	keyval = _tmp1_;
	_tmp2_ = event;
	_tmp3_ = _tmp2_->state;
	modifiers = (guint) _tmp3_;
	_tmp4_ = keyval;
	switch (_tmp4_) {
		case GDK_KEY_Escape:
		{
			gboolean _tmp5_;
			_tmp5_ = ibus_emojier_key_press_escape (self);
			if (_tmp5_) {
				result = TRUE;
				return result;
			}
			break;
		}
		case GDK_KEY_Return:
		{
			ibus_emojier_key_press_enter (self);
			result = TRUE;
			return result;
		}
		case GDK_KEY_BackSpace:
		{
			IBusEmojierEEntry* _tmp6_;
			const gchar* _tmp7_;
			gint _tmp8_;
			gint _tmp9_;
			_tmp6_ = self->priv->m_entry;
			_tmp7_ = gtk_entry_get_text ((GtkEntry*) _tmp6_);
			_tmp8_ = strlen (_tmp7_);
			_tmp9_ = _tmp8_;
			if (_tmp9_ > 0) {
				guint _tmp10_;
				_tmp10_ = modifiers;
				if ((_tmp10_ & GDK_CONTROL_MASK) != ((guint) 0)) {
					IBusEmojierEEntry* _tmp11_;
					_tmp11_ = self->priv->m_entry;
					g_signal_emit_by_name (_tmp11_, "delete-from-cursor", GTK_DELETE_WORD_ENDS, -1, NULL);
				} else {
					IBusEmojierEEntry* _tmp12_;
					_tmp12_ = self->priv->m_entry;
					g_signal_emit_by_name (_tmp12_, "backspace", NULL);
				}
				result = TRUE;
				return result;
			}
			break;
		}
		case GDK_KEY_Delete:
		case GDK_KEY_KP_Delete:
		{
			IBusEmojierEEntry* _tmp13_;
			const gchar* _tmp14_;
			gint _tmp15_;
			gint _tmp16_;
			_tmp13_ = self->priv->m_entry;
			_tmp14_ = gtk_entry_get_text ((GtkEntry*) _tmp13_);
			_tmp15_ = strlen (_tmp14_);
			_tmp16_ = _tmp15_;
			if (_tmp16_ > 0) {
				guint _tmp17_;
				_tmp17_ = modifiers;
				if ((_tmp17_ & GDK_CONTROL_MASK) != ((guint) 0)) {
					IBusEmojierEEntry* _tmp18_;
					_tmp18_ = self->priv->m_entry;
					g_signal_emit_by_name (_tmp18_, "delete-from-cursor", GTK_DELETE_WORD_ENDS, 1, NULL);
				} else {
					IBusEmojierEEntry* _tmp19_;
					_tmp19_ = self->priv->m_entry;
					g_signal_emit_by_name (_tmp19_, "delete-from-cursor", GTK_DELETE_CHARS, 1, NULL);
				}
				result = TRUE;
				return result;
			}
			break;
		}
		case GDK_KEY_space:
		case GDK_KEY_KP_Space:
		{
			guint _tmp20_;
			_tmp20_ = modifiers;
			if ((_tmp20_ & GDK_SHIFT_MASK) != ((guint) 0)) {
				IBusEmojierEEntry* _tmp21_;
				const gchar* _tmp22_;
				gint _tmp23_;
				gint _tmp24_;
				_tmp21_ = self->priv->m_entry;
				_tmp22_ = gtk_entry_get_text ((GtkEntry*) _tmp21_);
				_tmp23_ = strlen (_tmp22_);
				_tmp24_ = _tmp23_;
				if (_tmp24_ > 0) {
					guint _tmp25_;
					_tmp25_ = keyval;
					ibus_emojier_entry_enter_keyval (self, _tmp25_);
				}
			} else {
				gboolean _tmp26_;
				_tmp26_ = self->priv->m_candidate_panel_is_visible;
				if (_tmp26_) {
					IBusLookupTable* _tmp27_;
					ibus_emojier_enter_notify_disable_with_timer (self);
					_tmp27_ = self->priv->m_lookup_table;
					ibus_lookup_table_cursor_down (_tmp27_);
					ibus_emojier_show_candidate_panel (self);
				} else {
					ibus_emojier_category_list_cursor_move (self, (guint) GDK_KEY_Down);
				}
			}
			result = TRUE;
			return result;
		}
		case GDK_KEY_Right:
		{
			guint _tmp28_;
			guint _tmp29_;
			_tmp28_ = keyval;
			_tmp29_ = modifiers;
			ibus_emojier_key_press_cursor_horizontal (self, _tmp28_, _tmp29_);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Left:
		{
			guint _tmp30_;
			guint _tmp31_;
			_tmp30_ = keyval;
			_tmp31_ = modifiers;
			ibus_emojier_key_press_cursor_horizontal (self, _tmp30_, _tmp31_);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Down:
		{
			guint _tmp32_;
			_tmp32_ = keyval;
			ibus_emojier_key_press_cursor_vertical (self, _tmp32_);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Up:
		{
			guint _tmp33_;
			_tmp33_ = keyval;
			ibus_emojier_key_press_cursor_vertical (self, _tmp33_);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Page_Down:
		{
			gboolean _tmp34_;
			_tmp34_ = self->priv->m_candidate_panel_is_visible;
			if (_tmp34_) {
				IBusLookupTable* _tmp35_;
				ibus_emojier_enter_notify_disable_with_timer (self);
				_tmp35_ = self->priv->m_lookup_table;
				ibus_lookup_table_page_down (_tmp35_);
				ibus_emojier_show_candidate_panel (self);
				result = TRUE;
				return result;
			}
			break;
		}
		case GDK_KEY_Page_Up:
		{
			gboolean _tmp36_;
			_tmp36_ = self->priv->m_candidate_panel_is_visible;
			if (_tmp36_) {
				IBusLookupTable* _tmp37_;
				ibus_emojier_enter_notify_disable_with_timer (self);
				_tmp37_ = self->priv->m_lookup_table;
				ibus_lookup_table_page_up (_tmp37_);
				ibus_emojier_show_candidate_panel (self);
				result = TRUE;
				return result;
			}
			break;
		}
		case GDK_KEY_Home:
		{
			guint _tmp38_;
			guint _tmp39_;
			gboolean _tmp40_;
			_tmp38_ = keyval;
			_tmp39_ = modifiers;
			_tmp40_ = ibus_emojier_key_press_cursor_home_end (self, _tmp38_, _tmp39_);
			if (_tmp40_) {
				result = TRUE;
				return result;
			}
			break;
		}
		case GDK_KEY_End:
		{
			guint _tmp41_;
			guint _tmp42_;
			gboolean _tmp43_;
			_tmp41_ = keyval;
			_tmp42_ = modifiers;
			_tmp43_ = ibus_emojier_key_press_cursor_home_end (self, _tmp41_, _tmp42_);
			if (_tmp43_) {
				result = TRUE;
				return result;
			}
			break;
		}
		case GDK_KEY_Insert:
		case GDK_KEY_KP_Insert:
		{
			IBusEmojierEEntry* _tmp44_;
			_tmp44_ = self->priv->m_entry;
			g_signal_emit_by_name (_tmp44_, "toggle-overwrite", NULL);
			result = TRUE;
			return result;
		}
		default:
		break;
	}
	_tmp45_ = modifiers;
	if ((_tmp45_ & GDK_CONTROL_MASK) != ((guint) 0)) {
		guint _tmp46_;
		_tmp46_ = keyval;
		switch (_tmp46_) {
			case GDK_KEY_f:
			{
				guint _tmp47_;
				_tmp47_ = modifiers;
				ibus_emojier_key_press_cursor_horizontal (self, (guint) GDK_KEY_Right, _tmp47_);
				result = TRUE;
				return result;
			}
			case GDK_KEY_b:
			{
				guint _tmp48_;
				_tmp48_ = modifiers;
				ibus_emojier_key_press_cursor_horizontal (self, (guint) GDK_KEY_Left, _tmp48_);
				result = TRUE;
				return result;
			}
			case GDK_KEY_n:
			{
				ibus_emojier_key_press_cursor_vertical (self, (guint) GDK_KEY_Down);
				result = TRUE;
				return result;
			}
			case GDK_KEY_p:
			{
				ibus_emojier_key_press_cursor_vertical (self, (guint) GDK_KEY_Up);
				result = TRUE;
				return result;
			}
			case GDK_KEY_h:
			{
				guint _tmp49_;
				gboolean _tmp50_;
				_tmp49_ = modifiers;
				_tmp50_ = ibus_emojier_key_press_cursor_home_end (self, (guint) GDK_KEY_Home, _tmp49_);
				if (_tmp50_) {
					result = TRUE;
					return result;
				}
				break;
			}
			case GDK_KEY_e:
			{
				guint _tmp51_;
				gboolean _tmp52_;
				_tmp51_ = modifiers;
				_tmp52_ = ibus_emojier_key_press_cursor_home_end (self, (guint) GDK_KEY_End, _tmp51_);
				if (_tmp52_) {
					result = TRUE;
					return result;
				}
				break;
			}
			case GDK_KEY_u:
			{
				IBusEmojierEEntry* _tmp53_;
				const gchar* _tmp54_;
				gint _tmp55_;
				gint _tmp56_;
				_tmp53_ = self->priv->m_entry;
				_tmp54_ = gtk_entry_get_text ((GtkEntry*) _tmp53_);
				_tmp55_ = strlen (_tmp54_);
				_tmp56_ = _tmp55_;
				if (_tmp56_ > 0) {
					IBusEmojierEEntry* _tmp57_;
					_tmp57_ = self->priv->m_entry;
					g_signal_emit_by_name (_tmp57_, "delete-from-cursor", GTK_DELETE_PARAGRAPH_ENDS, -1, NULL);
					result = TRUE;
					return result;
				}
				break;
			}
			case GDK_KEY_a:
			{
				IBusEmojierEEntry* _tmp58_;
				const gchar* _tmp59_;
				gint _tmp60_;
				gint _tmp61_;
				_tmp58_ = self->priv->m_entry;
				_tmp59_ = gtk_entry_get_text ((GtkEntry*) _tmp58_);
				_tmp60_ = strlen (_tmp59_);
				_tmp61_ = _tmp60_;
				if (_tmp61_ > 0) {
					IBusEmojierEEntry* _tmp62_;
					_tmp62_ = self->priv->m_entry;
					gtk_editable_select_region ((GtkEditable*) _tmp62_, 0, -1);
					result = TRUE;
					return result;
				}
				break;
			}
			case GDK_KEY_x:
			{
				IBusEmojierEEntry* _tmp63_;
				const gchar* _tmp64_;
				gint _tmp65_;
				gint _tmp66_;
				_tmp63_ = self->priv->m_entry;
				_tmp64_ = gtk_entry_get_text ((GtkEntry*) _tmp63_);
				_tmp65_ = strlen (_tmp64_);
				_tmp66_ = _tmp65_;
				if (_tmp66_ > 0) {
					IBusEmojierEEntry* _tmp67_;
					_tmp67_ = self->priv->m_entry;
					g_signal_emit_by_name (_tmp67_, "cut-clipboard", NULL);
					result = TRUE;
					return result;
				}
				break;
			}
			case GDK_KEY_C:
			case GDK_KEY_c:
			{
				guint _tmp68_;
				_tmp68_ = modifiers;
				if ((_tmp68_ & GDK_SHIFT_MASK) != ((guint) 0)) {
					gboolean _tmp69_;
					_tmp69_ = self->priv->m_candidate_panel_is_visible;
					if (_tmp69_) {
						guint index = 0U;
						IBusLookupTable* _tmp70_;
						guint _tmp71_;
						gchar* text = NULL;
						IBusLookupTable* _tmp72_;
						guint _tmp73_;
						IBusText* _tmp74_;
						const gchar* _tmp75_;
						gchar* _tmp76_;
						GtkClipboard* clipboard = NULL;
						GtkClipboard* _tmp77_;
						GtkClipboard* _tmp78_;
						GtkClipboard* _tmp79_;
						const gchar* _tmp80_;
						GtkClipboard* _tmp81_;
						_tmp70_ = self->priv->m_lookup_table;
						_tmp71_ = ibus_lookup_table_get_cursor_pos (_tmp70_);
						index = _tmp71_;
						_tmp72_ = self->priv->m_lookup_table;
						_tmp73_ = index;
						_tmp74_ = ibus_lookup_table_get_candidate (_tmp72_, _tmp73_);
						_tmp75_ = _tmp74_->text;
						_tmp76_ = g_strdup (_tmp75_);
						text = _tmp76_;
						_tmp77_ = gtk_clipboard_get (GDK_SELECTION_CLIPBOARD);
						_tmp78_ = _g_object_ref0 (_tmp77_);
						clipboard = _tmp78_;
						_tmp79_ = clipboard;
						_tmp80_ = text;
						gtk_clipboard_set_text (_tmp79_, _tmp80_, -1);
						_tmp81_ = clipboard;
						gtk_clipboard_store (_tmp81_);
						result = TRUE;
						_g_object_unref0 (clipboard);
						_g_free0 (text);
						return result;
					}
				} else {
					IBusEmojierEEntry* _tmp82_;
					const gchar* _tmp83_;
					gint _tmp84_;
					gint _tmp85_;
					_tmp82_ = self->priv->m_entry;
					_tmp83_ = gtk_entry_get_text ((GtkEntry*) _tmp82_);
					_tmp84_ = strlen (_tmp83_);
					_tmp85_ = _tmp84_;
					if (_tmp85_ > 0) {
						IBusEmojierEEntry* _tmp86_;
						_tmp86_ = self->priv->m_entry;
						g_signal_emit_by_name (_tmp86_, "copy-clipboard", NULL);
						result = TRUE;
						return result;
					}
				}
				break;
			}
			case GDK_KEY_v:
			{
				IBusEmojierEEntry* _tmp87_;
				_tmp87_ = self->priv->m_entry;
				g_signal_emit_by_name (_tmp87_, "paste-clipboard", NULL);
				result = TRUE;
				return result;
			}
			default:
			break;
		}
		result = FALSE;
		return result;
	}
	_tmp88_ = keyval;
	ibus_emojier_entry_enter_keyval (self, _tmp88_);
	result = TRUE;
	return result;
}


gboolean ibus_emojier_is_running (IBusEmojier* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->m_is_running;
	result = _tmp0_;
	return result;
}


gchar* ibus_emojier_get_input_context_path (IBusEmojier* self) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->m_input_context_path;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


gchar* ibus_emojier_get_selected_string (IBusEmojier* self) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->m_result;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


void ibus_emojier_reset (IBusEmojier* self) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("");
	_g_free0 (self->priv->m_input_context_path);
	self->priv->m_input_context_path = _tmp0_;
	_g_free0 (self->priv->m_result);
	self->priv->m_result = NULL;
}


void ibus_emojier_present_centralize (IBusEmojier* self, GdkEvent* event) {
	GtkAllocation allocation = {0};
	GtkAllocation _tmp0_ = {0};
	GdkRectangle monitor_area = {0};
	GdkDisplay* display = NULL;
	GdkDisplay* _tmp1_;
	GdkDisplay* _tmp2_;
	GdkMonitor* monitor = NULL;
	GdkWindow* _tmp3_;
	GdkMonitor* _tmp4_;
	GdkMonitor* _tmp5_;
	GdkRectangle _tmp6_ = {0};
	gint x = 0;
	GdkRectangle _tmp7_;
	gint _tmp8_;
	GdkRectangle _tmp9_;
	gint _tmp10_;
	GtkAllocation _tmp11_;
	gint _tmp12_;
	gint y = 0;
	GdkRectangle _tmp13_;
	gint _tmp14_;
	GdkRectangle _tmp15_;
	gint _tmp16_;
	GtkAllocation _tmp17_;
	gint _tmp18_;
	guint32 timestamp = 0U;
	GdkEvent* _tmp19_;
	guint32 _tmp20_;
	IBusEmojierEEntry* _tmp21_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp0_);
	allocation = _tmp0_;
	_tmp1_ = gdk_display_get_default ();
	_tmp2_ = _g_object_ref0 (_tmp1_);
	display = _tmp2_;
	_tmp3_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp4_ = gdk_display_get_monitor_at_window (display, _tmp3_);
	_tmp5_ = _g_object_ref0 (_tmp4_);
	monitor = _tmp5_;
	gdk_monitor_get_geometry (monitor, &_tmp6_);
	monitor_area = _tmp6_;
	_tmp7_ = monitor_area;
	_tmp8_ = _tmp7_.x;
	_tmp9_ = monitor_area;
	_tmp10_ = _tmp9_.width;
	_tmp11_ = allocation;
	_tmp12_ = _tmp11_.width;
	x = ((_tmp8_ + _tmp10_) - _tmp12_) / 2;
	_tmp13_ = monitor_area;
	_tmp14_ = _tmp13_.y;
	_tmp15_ = monitor_area;
	_tmp16_ = _tmp15_.height;
	_tmp17_ = allocation;
	_tmp18_ = _tmp17_.height;
	y = ((_tmp14_ + _tmp16_) - _tmp18_) / 2;
	gtk_window_move ((GtkWindow*) self, x, y);
	_tmp19_ = event;
	_tmp20_ = gdk_event_get_time (_tmp19_);
	timestamp = _tmp20_;
	gtk_window_present_with_time ((GtkWindow*) self, timestamp);
	_tmp21_ = self->priv->m_entry;
	gtk_entry_set_activates_default ((GtkEntry*) _tmp21_, TRUE);
	_g_object_unref0 (monitor);
	_g_object_unref0 (display);
}


gboolean ibus_emojier_has_loaded_emoji_dict (void) {
	gboolean result = FALSE;
	GHashTable* _tmp0_;
	GList* keys = NULL;
	GHashTable* _tmp1_;
	GList* _tmp2_;
	GList* _tmp3_;
	guint _tmp4_;
	_tmp0_ = ibus_emojier_m_emoji_to_data_dict;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = ibus_emojier_m_emoji_to_data_dict;
	_tmp2_ = g_hash_table_get_keys (_tmp1_);
	keys = _tmp2_;
	_tmp3_ = keys;
	_tmp4_ = g_list_length (_tmp3_);
	if (_tmp4_ == ((guint) 0)) {
		result = FALSE;
		_g_list_free0 (keys);
		return result;
	}
	result = TRUE;
	_g_list_free0 (keys);
	return result;
}


void ibus_emojier_set_annotation_lang (const gchar* lang) {
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	_tmp1_ = lang;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		const gchar* _tmp2_;
		_tmp2_ = lang;
		_tmp0_ = g_strcmp0 (_tmp2_, "") == 0;
	}
	if (_tmp0_) {
		lang = "en";
	}
	_tmp3_ = ibus_emojier_m_current_lang_id;
	_tmp4_ = lang;
	if (g_strcmp0 (_tmp3_, _tmp4_) == 0) {
		return;
	}
	_tmp5_ = lang;
	_tmp6_ = g_strdup (_tmp5_);
	_g_free0 (ibus_emojier_m_current_lang_id);
	ibus_emojier_m_current_lang_id = _tmp6_;
	ibus_emojier_reload_emoji_dict ();
}


static void _vala_PangoFontDescription_free (PangoFontDescription* self) {
	g_boxed_free (pango_font_description_get_type (), self);
}


void ibus_emojier_set_emoji_font (const gchar* emoji_font) {
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	PangoFontDescription* font_desc = NULL;
	const gchar* _tmp3_;
	PangoFontDescription* _tmp4_;
	gchar* font_family = NULL;
	PangoFontDescription* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	const gchar* _tmp8_;
	gint font_size = 0;
	PangoFontDescription* _tmp11_;
	gint _tmp12_;
	gint _tmp13_;
	_tmp1_ = emoji_font;
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_;
		_tmp2_ = emoji_font;
		_tmp0_ = g_strcmp0 (_tmp2_, "") != 0;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_if_fail (_tmp0_);
	_tmp3_ = emoji_font;
	_tmp4_ = pango_font_description_from_string (_tmp3_);
	font_desc = _tmp4_;
	_tmp5_ = font_desc;
	_tmp6_ = pango_font_description_get_family (_tmp5_);
	_tmp7_ = g_strdup (_tmp6_);
	font_family = _tmp7_;
	_tmp8_ = font_family;
	if (_tmp8_ != NULL) {
		const gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp9_ = font_family;
		_tmp10_ = g_strdup (_tmp9_);
		_g_free0 (ibus_emojier_m_emoji_font_family);
		ibus_emojier_m_emoji_font_family = _tmp10_;
	}
	_tmp11_ = font_desc;
	_tmp12_ = pango_font_description_get_size (_tmp11_);
	font_size = _tmp12_ / PANGO_SCALE;
	_tmp13_ = font_size;
	if (_tmp13_ != 0) {
		gint _tmp14_;
		_tmp14_ = font_size;
		ibus_emojier_m_emoji_font_size = _tmp14_;
	}
	_g_free0 (font_family);
	__vala_PangoFontDescription_free0 (font_desc);
}


void ibus_emojier_set_partial_match (gboolean has_partial_match) {
	gboolean _tmp0_;
	_tmp0_ = has_partial_match;
	ibus_emojier_m_has_partial_match = _tmp0_;
}


void ibus_emojier_set_partial_match_length (gint length) {
	gint _tmp0_;
	gint _tmp1_;
	_tmp0_ = length;
	if (_tmp0_ < 1) {
		return;
	}
	_tmp1_ = length;
	ibus_emojier_m_partial_match_length = (guint) _tmp1_;
}


void ibus_emojier_set_partial_match_condition (gint condition) {
	gint _tmp0_;
	gint _tmp1_;
	_tmp0_ = condition;
	if (_tmp0_ < 0) {
		return;
	}
	_tmp1_ = condition;
	ibus_emojier_m_partial_match_condition = (guint) _tmp1_;
}


static void _vala_array_add9 (gchar** * array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add10 (gchar** * array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


void ibus_emojier_set_favorites (gchar** unowned_favorites, int unowned_favorites_length1, gchar** unowned_favorite_annotations, int unowned_favorite_annotations_length1) {
	gchar** _tmp0_;
	gchar** _tmp1_;
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	ibus_emojier_m_favorites = (_vala_array_free (ibus_emojier_m_favorites, ibus_emojier_m_favorites_length1, (GDestroyNotify) g_free), NULL);
	ibus_emojier_m_favorites = _tmp0_;
	ibus_emojier_m_favorites_length1 = 0;
	_ibus_emojier_m_favorites_size_ = ibus_emojier_m_favorites_length1;
	_tmp1_ = g_new0 (gchar*, 0 + 1);
	ibus_emojier_m_favorite_annotations = (_vala_array_free (ibus_emojier_m_favorite_annotations, ibus_emojier_m_favorite_annotations_length1, (GDestroyNotify) g_free), NULL);
	ibus_emojier_m_favorite_annotations = _tmp1_;
	ibus_emojier_m_favorite_annotations_length1 = 0;
	_ibus_emojier_m_favorite_annotations_size_ = ibus_emojier_m_favorite_annotations_length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_;
				gchar** _tmp5_;
				gint _tmp5__length1;
				gchar* favorite = NULL;
				gchar** _tmp6_;
				gint _tmp6__length1;
				gint _tmp7_;
				const gchar* _tmp8_;
				gchar* _tmp9_;
				const gchar* _tmp10_;
				const gchar* _tmp11_;
				gchar** _tmp12_;
				gint _tmp12__length1;
				const gchar* _tmp13_;
				gchar* _tmp14_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = unowned_favorites;
				_tmp5__length1 = unowned_favorites_length1;
				if (!(_tmp4_ < _tmp5__length1)) {
					break;
				}
				_tmp6_ = unowned_favorites;
				_tmp6__length1 = unowned_favorites_length1;
				_tmp7_ = i;
				_tmp8_ = _tmp6_[_tmp7_];
				_tmp9_ = g_strdup (_tmp8_);
				favorite = _tmp9_;
				_tmp10_ = favorite;
				g_return_if_fail (_tmp10_ != NULL);
				_tmp11_ = favorite;
				g_return_if_fail (g_strcmp0 (_tmp11_, "") != 0);
				_tmp12_ = ibus_emojier_m_favorites;
				_tmp12__length1 = ibus_emojier_m_favorites_length1;
				_tmp13_ = favorite;
				_tmp14_ = g_strdup (_tmp13_);
				_vala_array_add9 (&ibus_emojier_m_favorites, &ibus_emojier_m_favorites_length1, &_ibus_emojier_m_favorites_size_, _tmp14_);
				_g_free0 (favorite);
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp15_ = FALSE;
			_tmp15_ = TRUE;
			while (TRUE) {
				gint _tmp17_;
				gchar** _tmp18_;
				gint _tmp18__length1;
				gchar* favorite_annotation = NULL;
				gchar** _tmp19_;
				gint _tmp19__length1;
				gint _tmp20_;
				const gchar* _tmp21_;
				gchar* _tmp22_;
				const gchar* _tmp23_;
				gchar** _tmp24_;
				gint _tmp24__length1;
				const gchar* _tmp25_;
				gchar* _tmp26_;
				if (!_tmp15_) {
					gint _tmp16_;
					_tmp16_ = i;
					i = _tmp16_ + 1;
				}
				_tmp15_ = FALSE;
				_tmp17_ = i;
				_tmp18_ = unowned_favorite_annotations;
				_tmp18__length1 = unowned_favorite_annotations_length1;
				if (!(_tmp17_ < _tmp18__length1)) {
					break;
				}
				_tmp19_ = unowned_favorite_annotations;
				_tmp19__length1 = unowned_favorite_annotations_length1;
				_tmp20_ = i;
				_tmp21_ = _tmp19_[_tmp20_];
				_tmp22_ = g_strdup (_tmp21_);
				favorite_annotation = _tmp22_;
				_tmp23_ = favorite_annotation;
				g_return_if_fail (_tmp23_ != NULL);
				_tmp24_ = ibus_emojier_m_favorite_annotations;
				_tmp24__length1 = ibus_emojier_m_favorite_annotations_length1;
				_tmp25_ = favorite_annotation;
				_tmp26_ = g_strdup (_tmp25_);
				_vala_array_add10 (&ibus_emojier_m_favorite_annotations, &ibus_emojier_m_favorite_annotations_length1, &_ibus_emojier_m_favorite_annotations_size_, _tmp26_);
				_g_free0 (favorite_annotation);
			}
		}
	}
	ibus_emojier_update_favorite_emoji_dict ();
}


static void g_cclosure_user_marshal_VOID__UINT_UINT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__UINT_UINT_UINT) (gpointer data1, guint arg_1, guint arg_2, guint arg_3, gpointer data2);
	register GMarshalFunc_VOID__UINT_UINT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT_UINT_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint (param_values + 1), g_value_get_uint (param_values + 2), g_value_get_uint (param_values + 3), data2);
}


static IBusEmojierEEntry* ibus_emojier_eentry_construct (GType object_type) {
	IBusEmojierEEntry * self = NULL;
	self = (IBusEmojierEEntry*) g_object_new (object_type, "name", "IBusEmojierEntry", "margin-start", 6, "margin-end", 6, "margin-top", 6, "margin-bottom", 6, NULL);
	return self;
}


static IBusEmojierEEntry* ibus_emojier_eentry_new (void) {
	return ibus_emojier_eentry_construct (IBUS_EMOJIER_TYPE_EENTRY);
}


static void ibus_emojier_eentry_class_init (IBusEmojierEEntryClass * klass) {
	ibus_emojier_eentry_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_eentry_instance_init (IBusEmojierEEntry * self) {
}


static GType ibus_emojier_eentry_get_type (void) {
	static volatile gsize ibus_emojier_eentry_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_eentry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_eentry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEEntry), 0, (GInstanceInitFunc) ibus_emojier_eentry_instance_init, NULL };
		GType ibus_emojier_eentry_type_id;
		ibus_emojier_eentry_type_id = g_type_register_static (gtk_search_entry_get_type (), "IBusEmojierEEntry", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_eentry_type_id__volatile, ibus_emojier_eentry_type_id);
	}
	return ibus_emojier_eentry_type_id__volatile;
}


static gboolean __lambda10_ (IBusEmojierEListBox* self, GdkEventMotion* e) {
	gboolean result = FALSE;
	GdkEventMotion* pe = NULL;
	GdkEventMotion* _tmp0_;
	GdkEventMotion* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gdouble _tmp3_;
	GdkEventMotion* _tmp4_;
	gdouble _tmp5_;
	GdkEventMotion* _tmp9_;
	gdouble _tmp10_;
	GdkEventMotion* _tmp11_;
	gdouble _tmp12_;
	GtkListBoxRow* row = NULL;
	GdkEventMotion* _tmp13_;
	gdouble _tmp14_;
	GtkListBoxRow* _tmp15_;
	GtkListBoxRow* _tmp16_;
	GtkListBoxRow* _tmp17_;
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = e;
	_tmp1_ = __vala_GdkEventMotion_copy0 (_tmp0_);
	pe = _tmp1_;
	_tmp3_ = ibus_emojier_m_mouse_x;
	_tmp4_ = pe;
	_tmp5_ = _tmp4_->x_root;
	if (_tmp3_ == _tmp5_) {
		gdouble _tmp6_;
		GdkEventMotion* _tmp7_;
		gdouble _tmp8_;
		_tmp6_ = ibus_emojier_m_mouse_y;
		_tmp7_ = pe;
		_tmp8_ = _tmp7_->y_root;
		_tmp2_ = _tmp6_ == _tmp8_;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		result = FALSE;
		__vala_GdkEventMotion_free0 (pe);
		return result;
	}
	_tmp9_ = pe;
	_tmp10_ = _tmp9_->x_root;
	ibus_emojier_m_mouse_x = _tmp10_;
	_tmp11_ = pe;
	_tmp12_ = _tmp11_->y_root;
	ibus_emojier_m_mouse_y = _tmp12_;
	_tmp13_ = e;
	_tmp14_ = _tmp13_->y;
	_tmp15_ = gtk_list_box_get_row_at_y ((GtkListBox*) self, (gint) _tmp14_);
	_tmp16_ = _g_object_ref0 (_tmp15_);
	row = _tmp16_;
	_tmp17_ = row;
	if (_tmp17_ != NULL) {
		GtkListBoxRow* _tmp18_;
		_tmp18_ = row;
		gtk_list_box_select_row ((GtkListBox*) self, _tmp18_);
	}
	result = FALSE;
	_g_object_unref0 (row);
	__vala_GdkEventMotion_free0 (pe);
	return result;
}


static gboolean ___lambda10__gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = __lambda10_ ((IBusEmojierEListBox*) self, event);
	return result;
}


static gboolean __lambda11_ (IBusEmojierEListBox* self, GdkEventCrossing* e) {
	gboolean result = FALSE;
	g_return_val_if_fail (e != NULL, FALSE);
	result = TRUE;
	return result;
}


static gboolean ___lambda11__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = __lambda11_ ((IBusEmojierEListBox*) self, event);
	return result;
}


static IBusEmojierEListBox* ibus_emojier_elist_box_construct (GType object_type) {
	IBusEmojierEListBox * self = NULL;
	self = (IBusEmojierEListBox*) g_object_new (object_type, "vexpand", TRUE, "halign", GTK_ALIGN_FILL, "valign", GTK_ALIGN_FILL, NULL);
	g_signal_connect_object ((GtkWidget*) self, "motion-notify-event", (GCallback) ___lambda10__gtk_widget_motion_notify_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "enter-notify-event", (GCallback) ___lambda11__gtk_widget_enter_notify_event, self, 0);
	return self;
}


static IBusEmojierEListBox* ibus_emojier_elist_box_new (void) {
	return ibus_emojier_elist_box_construct (IBUS_EMOJIER_TYPE_ELIST_BOX);
}


static void ibus_emojier_elist_box_class_init (IBusEmojierEListBoxClass * klass) {
	ibus_emojier_elist_box_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_elist_box_instance_init (IBusEmojierEListBox * self) {
}


static GType ibus_emojier_elist_box_get_type (void) {
	static volatile gsize ibus_emojier_elist_box_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_elist_box_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEListBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_elist_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEListBox), 0, (GInstanceInitFunc) ibus_emojier_elist_box_instance_init, NULL };
		GType ibus_emojier_elist_box_type_id;
		ibus_emojier_elist_box_type_id = g_type_register_static (gtk_list_box_get_type (), "IBusEmojierEListBox", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_elist_box_type_id__volatile, ibus_emojier_elist_box_type_id);
	}
	return ibus_emojier_elist_box_type_id__volatile;
}


static IBusEmojierEBoxRow* ibus_emojier_ebox_row_construct (GType object_type, const gchar* text) {
	IBusEmojierEBoxRow * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEBoxRow*) g_object_new (object_type, NULL);
	_tmp0_ = text;
	ibus_emojier_ebox_row_set_text (self, _tmp0_);
	return self;
}


static IBusEmojierEBoxRow* ibus_emojier_ebox_row_new (const gchar* text) {
	return ibus_emojier_ebox_row_construct (IBUS_EMOJIER_TYPE_EBOX_ROW, text);
}


static const gchar* ibus_emojier_ebox_row_get_text (IBusEmojierEBoxRow* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_text;
	result = _tmp0_;
	return result;
}


static void ibus_emojier_ebox_row_set_text (IBusEmojierEBoxRow* self, const gchar* value) {
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, ibus_emojier_ebox_row_get_text (self)) != 0) {
		const gchar* _tmp0_;
		gchar* _tmp1_;
		_tmp0_ = value;
		_tmp1_ = g_strdup (_tmp0_);
		_g_free0 (self->priv->_text);
		self->priv->_text = _tmp1_;
		g_object_notify_by_pspec ((GObject *) self, ibus_emojier_ebox_row_properties[IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY]);
	}
}


static void ibus_emojier_ebox_row_class_init (IBusEmojierEBoxRowClass * klass) {
	ibus_emojier_ebox_row_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IBusEmojierEBoxRowPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_ibus_emojier_ebox_row_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_ibus_emojier_ebox_row_set_property;
	G_OBJECT_CLASS (klass)->finalize = ibus_emojier_ebox_row_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY, ibus_emojier_ebox_row_properties[IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY] = g_param_spec_string ("text", "text", "text", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void ibus_emojier_ebox_row_instance_init (IBusEmojierEBoxRow * self) {
	self->priv = IBUS_EMOJIER_EBOX_ROW_GET_PRIVATE (self);
}


static void ibus_emojier_ebox_row_finalize (GObject * obj) {
	IBusEmojierEBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRow);
	_g_free0 (self->priv->_text);
	G_OBJECT_CLASS (ibus_emojier_ebox_row_parent_class)->finalize (obj);
}


static GType ibus_emojier_ebox_row_get_type (void) {
	static volatile gsize ibus_emojier_ebox_row_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_ebox_row_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEBoxRowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_ebox_row_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEBoxRow), 0, (GInstanceInitFunc) ibus_emojier_ebox_row_instance_init, NULL };
		GType ibus_emojier_ebox_row_type_id;
		ibus_emojier_ebox_row_type_id = g_type_register_static (gtk_list_box_row_get_type (), "IBusEmojierEBoxRow", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_ebox_row_type_id__volatile, ibus_emojier_ebox_row_type_id);
	}
	return ibus_emojier_ebox_row_type_id__volatile;
}


static void _vala_ibus_emojier_ebox_row_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	IBusEmojierEBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRow);
	switch (property_id) {
		case IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY:
		g_value_set_string (value, ibus_emojier_ebox_row_get_text (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_ibus_emojier_ebox_row_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	IBusEmojierEBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRow);
	switch (property_id) {
		case IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY:
		ibus_emojier_ebox_row_set_text (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static IBusEmojierEScrolledWindow* ibus_emojier_escrolled_window_construct (GType object_type, GtkAdjustment* hadjustment, GtkAdjustment* vadjustment) {
	IBusEmojierEScrolledWindow * self = NULL;
	GtkAdjustment* _tmp0_;
	GtkAdjustment* _tmp2_;
	self = (IBusEmojierEScrolledWindow*) g_object_new (object_type, "hscrollbar-policy", GTK_POLICY_NEVER, "vscrollbar-policy", GTK_POLICY_NEVER, "shadow-type", GTK_SHADOW_IN, "margin-start", 6, "margin-end", 6, "margin-top", 6, "margin-bottom", 6, NULL);
	_tmp0_ = hadjustment;
	if (_tmp0_ != NULL) {
		GtkAdjustment* _tmp1_;
		_tmp1_ = hadjustment;
		gtk_scrolled_window_set_hadjustment ((GtkScrolledWindow*) self, _tmp1_);
	}
	_tmp2_ = vadjustment;
	if (_tmp2_ != NULL) {
		GtkAdjustment* _tmp3_;
		_tmp3_ = vadjustment;
		gtk_scrolled_window_set_hadjustment ((GtkScrolledWindow*) self, _tmp3_);
	}
	return self;
}


static IBusEmojierEScrolledWindow* ibus_emojier_escrolled_window_new (GtkAdjustment* hadjustment, GtkAdjustment* vadjustment) {
	return ibus_emojier_escrolled_window_construct (IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW, hadjustment, vadjustment);
}


static void ibus_emojier_escrolled_window_class_init (IBusEmojierEScrolledWindowClass * klass) {
	ibus_emojier_escrolled_window_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_escrolled_window_instance_init (IBusEmojierEScrolledWindow * self) {
}


static GType ibus_emojier_escrolled_window_get_type (void) {
	static volatile gsize ibus_emojier_escrolled_window_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_escrolled_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEScrolledWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_escrolled_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEScrolledWindow), 0, (GInstanceInitFunc) ibus_emojier_escrolled_window_instance_init, NULL };
		GType ibus_emojier_escrolled_window_type_id;
		ibus_emojier_escrolled_window_type_id = g_type_register_static (gtk_scrolled_window_get_type (), "IBusEmojierEScrolledWindow", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_escrolled_window_type_id__volatile, ibus_emojier_escrolled_window_type_id);
	}
	return ibus_emojier_escrolled_window_type_id__volatile;
}


static IBusEmojierEGrid* ibus_emojier_egrid_construct (GType object_type) {
	IBusEmojierEGrid * self = NULL;
	self = (IBusEmojierEGrid*) g_object_new (object_type, "row-homogeneous", FALSE, "vexpand", TRUE, "halign", GTK_ALIGN_FILL, "valign", GTK_ALIGN_FILL, "row-spacing", 5, "column-spacing", 5, "border-width", 2, NULL);
	return self;
}


static IBusEmojierEGrid* ibus_emojier_egrid_new (void) {
	return ibus_emojier_egrid_construct (IBUS_EMOJIER_TYPE_EGRID);
}


static void ibus_emojier_egrid_class_init (IBusEmojierEGridClass * klass) {
	ibus_emojier_egrid_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_egrid_instance_init (IBusEmojierEGrid * self) {
}


static GType ibus_emojier_egrid_get_type (void) {
	static volatile gsize ibus_emojier_egrid_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_egrid_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEGridClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_egrid_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEGrid), 0, (GInstanceInitFunc) ibus_emojier_egrid_instance_init, NULL };
		GType ibus_emojier_egrid_type_id;
		ibus_emojier_egrid_type_id = g_type_register_static (gtk_grid_get_type (), "IBusEmojierEGrid", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_egrid_type_id__volatile, ibus_emojier_egrid_type_id);
	}
	return ibus_emojier_egrid_type_id__volatile;
}


static IBusEmojierEWhiteLabel* ibus_emojier_ewhite_label_construct (GType object_type, const gchar* text) {
	IBusEmojierEWhiteLabel * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEWhiteLabel*) g_object_new (object_type, "name", "IBusEmojierWhiteLabel", NULL);
	_tmp0_ = text;
	if (g_strcmp0 (_tmp0_, "") != 0) {
		const gchar* _tmp1_;
		_tmp1_ = text;
		gtk_label_set_label ((GtkLabel*) self, _tmp1_);
	}
	return self;
}


static IBusEmojierEWhiteLabel* ibus_emojier_ewhite_label_new (const gchar* text) {
	return ibus_emojier_ewhite_label_construct (IBUS_EMOJIER_TYPE_EWHITE_LABEL, text);
}


static void ibus_emojier_ewhite_label_class_init (IBusEmojierEWhiteLabelClass * klass) {
	ibus_emojier_ewhite_label_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_ewhite_label_instance_init (IBusEmojierEWhiteLabel * self) {
}


static GType ibus_emojier_ewhite_label_get_type (void) {
	static volatile gsize ibus_emojier_ewhite_label_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_ewhite_label_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEWhiteLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_ewhite_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEWhiteLabel), 0, (GInstanceInitFunc) ibus_emojier_ewhite_label_instance_init, NULL };
		GType ibus_emojier_ewhite_label_type_id;
		ibus_emojier_ewhite_label_type_id = g_type_register_static (gtk_label_get_type (), "IBusEmojierEWhiteLabel", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_ewhite_label_type_id__volatile, ibus_emojier_ewhite_label_type_id);
	}
	return ibus_emojier_ewhite_label_type_id__volatile;
}


static IBusEmojierESelectedLabel* ibus_emojier_eselected_label_construct (GType object_type, const gchar* text) {
	IBusEmojierESelectedLabel * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierESelectedLabel*) g_object_new (object_type, "name", "IBusEmojierSelectedLabel", NULL);
	_tmp0_ = text;
	if (g_strcmp0 (_tmp0_, "") != 0) {
		const gchar* _tmp1_;
		_tmp1_ = text;
		gtk_label_set_label ((GtkLabel*) self, _tmp1_);
	}
	return self;
}


static IBusEmojierESelectedLabel* ibus_emojier_eselected_label_new (const gchar* text) {
	return ibus_emojier_eselected_label_construct (IBUS_EMOJIER_TYPE_ESELECTED_LABEL, text);
}


static void ibus_emojier_eselected_label_class_init (IBusEmojierESelectedLabelClass * klass) {
	ibus_emojier_eselected_label_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_eselected_label_instance_init (IBusEmojierESelectedLabel * self) {
}


static GType ibus_emojier_eselected_label_get_type (void) {
	static volatile gsize ibus_emojier_eselected_label_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_eselected_label_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierESelectedLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_eselected_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierESelectedLabel), 0, (GInstanceInitFunc) ibus_emojier_eselected_label_instance_init, NULL };
		GType ibus_emojier_eselected_label_type_id;
		ibus_emojier_eselected_label_type_id = g_type_register_static (gtk_label_get_type (), "IBusEmojierESelectedLabel", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_eselected_label_type_id__volatile, ibus_emojier_eselected_label_type_id);
	}
	return ibus_emojier_eselected_label_type_id__volatile;
}


static IBusEmojierEGoldLabel* ibus_emojier_egold_label_construct (GType object_type, const gchar* text) {
	IBusEmojierEGoldLabel * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEGoldLabel*) g_object_new (object_type, "name", "IBusEmojierGoldLabel", NULL);
	_tmp0_ = text;
	if (g_strcmp0 (_tmp0_, "") != 0) {
		const gchar* _tmp1_;
		_tmp1_ = text;
		gtk_label_set_label ((GtkLabel*) self, _tmp1_);
	}
	return self;
}


static IBusEmojierEGoldLabel* ibus_emojier_egold_label_new (const gchar* text) {
	return ibus_emojier_egold_label_construct (IBUS_EMOJIER_TYPE_EGOLD_LABEL, text);
}


static void ibus_emojier_egold_label_class_init (IBusEmojierEGoldLabelClass * klass) {
	ibus_emojier_egold_label_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_egold_label_instance_init (IBusEmojierEGoldLabel * self) {
}


static GType ibus_emojier_egold_label_get_type (void) {
	static volatile gsize ibus_emojier_egold_label_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_egold_label_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEGoldLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_egold_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEGoldLabel), 0, (GInstanceInitFunc) ibus_emojier_egold_label_instance_init, NULL };
		GType ibus_emojier_egold_label_type_id;
		ibus_emojier_egold_label_type_id = g_type_register_static (gtk_label_get_type (), "IBusEmojierEGoldLabel", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_egold_label_type_id__volatile, ibus_emojier_egold_label_type_id);
	}
	return ibus_emojier_egold_label_type_id__volatile;
}


static IBusEmojierEPaddedLabel* ibus_emojier_epadded_label_construct (GType object_type, const gchar* text, GtkAlign align) {
	IBusEmojierEPaddedLabel * self = NULL;
	GtkAlign _tmp0_;
	const gchar* _tmp1_;
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = align;
	self = (IBusEmojierEPaddedLabel*) g_object_new (object_type, "name", "IBusEmojierPaddedLabel", "halign", _tmp0_, "valign", GTK_ALIGN_CENTER, "margin-start", 20, "margin-end", 20, "margin-top", 6, "margin-bottom", 6, NULL);
	_tmp1_ = text;
	gtk_label_set_text ((GtkLabel*) self, _tmp1_);
	return self;
}


static IBusEmojierEPaddedLabel* ibus_emojier_epadded_label_new (const gchar* text, GtkAlign align) {
	return ibus_emojier_epadded_label_construct (IBUS_EMOJIER_TYPE_EPADDED_LABEL, text, align);
}


static void ibus_emojier_epadded_label_class_init (IBusEmojierEPaddedLabelClass * klass) {
	ibus_emojier_epadded_label_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_epadded_label_instance_init (IBusEmojierEPaddedLabel * self) {
}


static GType ibus_emojier_epadded_label_get_type (void) {
	static volatile gsize ibus_emojier_epadded_label_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_epadded_label_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEPaddedLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_epadded_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEPaddedLabel), 0, (GInstanceInitFunc) ibus_emojier_epadded_label_instance_init, NULL };
		GType ibus_emojier_epadded_label_type_id;
		ibus_emojier_epadded_label_type_id = g_type_register_static (gtk_label_get_type (), "IBusEmojierEPaddedLabel", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_epadded_label_type_id__volatile, ibus_emojier_epadded_label_type_id);
	}
	return ibus_emojier_epadded_label_type_id__volatile;
}


static IBusEmojierEPaddedLabelBox* ibus_emojier_epadded_label_box_construct (GType object_type, const gchar* text, GtkAlign align, IBusEmojierTravelDirection direction) {
	IBusEmojierEPaddedLabelBox * self = NULL;
	IBusEmojierTravelDirection _tmp0_;
	IBusEmojierEPaddedLabel* label = NULL;
	const gchar* _tmp5_;
	GtkAlign _tmp6_;
	IBusEmojierEPaddedLabel* _tmp7_;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEPaddedLabelBox*) g_object_new (object_type, "name", "IBusEmojierPaddedLabelBox", "orientation", GTK_ORIENTATION_HORIZONTAL, "spacing", 0, NULL);
	_tmp0_ = direction;
	if (_tmp0_ == IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD) {
		IconWidget* icon = NULL;
		GtkTextDirection _tmp1_;
		IconWidget* _tmp4_;
		_tmp1_ = gtk_widget_get_default_direction ();
		if (_tmp1_ == GTK_TEXT_DIR_RTL) {
			IconWidget* _tmp2_;
			_tmp2_ = icon_widget_new ("go-previous-rtl-symbolic", GTK_ICON_SIZE_MENU);
			g_object_ref_sink (_tmp2_);
			_g_object_unref0 (icon);
			icon = _tmp2_;
		} else {
			IconWidget* _tmp3_;
			_tmp3_ = icon_widget_new ("go-previous-symbolic", GTK_ICON_SIZE_MENU);
			g_object_ref_sink (_tmp3_);
			_g_object_unref0 (icon);
			icon = _tmp3_;
		}
		_tmp4_ = icon;
		gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp4_, FALSE, TRUE, (guint) 0);
		_g_object_unref0 (icon);
	}
	_tmp5_ = text;
	_tmp6_ = align;
	_tmp7_ = ibus_emojier_epadded_label_new (_tmp5_, _tmp6_);
	g_object_ref_sink (_tmp7_);
	label = _tmp7_;
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) label, TRUE, TRUE, (guint) 0);
	_g_object_unref0 (label);
	return self;
}


static IBusEmojierEPaddedLabelBox* ibus_emojier_epadded_label_box_new (const gchar* text, GtkAlign align, IBusEmojierTravelDirection direction) {
	return ibus_emojier_epadded_label_box_construct (IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX, text, align, direction);
}


static void ibus_emojier_epadded_label_box_class_init (IBusEmojierEPaddedLabelBoxClass * klass) {
	ibus_emojier_epadded_label_box_parent_class = g_type_class_peek_parent (klass);
}


static void ibus_emojier_epadded_label_box_instance_init (IBusEmojierEPaddedLabelBox * self) {
}


static GType ibus_emojier_epadded_label_box_get_type (void) {
	static volatile gsize ibus_emojier_epadded_label_box_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_epadded_label_box_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEPaddedLabelBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_epadded_label_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEPaddedLabelBox), 0, (GInstanceInitFunc) ibus_emojier_epadded_label_box_instance_init, NULL };
		GType ibus_emojier_epadded_label_box_type_id;
		ibus_emojier_epadded_label_box_type_id = g_type_register_static (gtk_box_get_type (), "IBusEmojierEPaddedLabelBox", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_epadded_label_box_type_id__volatile, ibus_emojier_epadded_label_box_type_id);
	}
	return ibus_emojier_epadded_label_box_type_id__volatile;
}


static IBusEmojierETitleLabelBox* ibus_emojier_etitle_label_box_construct (GType object_type, const gchar* title) {
	IBusEmojierETitleLabelBox * self = NULL;
	const gchar* _tmp0_;
	GtkBox* vbox = NULL;
	GtkBox* _tmp1_;
	GtkLabel* label = NULL;
	const gchar* _tmp2_;
	GtkLabel* _tmp3_;
	GtkStyleContext* _tmp4_;
	GtkLabel* _tmp5_;
	GtkLabel* _tmp6_;
	GtkStyleContext* _tmp7_;
	GtkLabel* _tmp8_;
	GMenu* menu = NULL;
	GMenu* _tmp9_;
	GtkMenuButton* menu_button = NULL;
	GtkMenuButton* _tmp10_;
	g_return_val_if_fail (title != NULL, NULL);
	_tmp0_ = title;
	self = (IBusEmojierETitleLabelBox*) g_object_new (object_type, "name", "IBusEmojierTitleLabelBox", "show-close-button", TRUE, "decoration-layout", ":close", "title", _tmp0_, NULL);
	_tmp1_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp1_);
	vbox = _tmp1_;
	gtk_header_bar_set_custom_title ((GtkHeaderBar*) self, (GtkWidget*) vbox);
	_tmp2_ = title;
	_tmp3_ = (GtkLabel*) gtk_label_new (_tmp2_);
	g_object_ref_sink (_tmp3_);
	label = _tmp3_;
	_tmp4_ = gtk_widget_get_style_context ((GtkWidget*) label);
	gtk_style_context_add_class (_tmp4_, GTK_STYLE_CLASS_TITLE);
	gtk_box_pack_start (vbox, (GtkWidget*) label, TRUE, FALSE, (guint) 0);
	_tmp5_ = (GtkLabel*) gtk_label_new (NULL);
	g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->m_lang_label);
	self->priv->m_lang_label = _tmp5_;
	_tmp6_ = self->priv->m_lang_label;
	_tmp7_ = gtk_widget_get_style_context ((GtkWidget*) _tmp6_);
	gtk_style_context_add_class (_tmp7_, GTK_STYLE_CLASS_SUBTITLE);
	_tmp8_ = self->priv->m_lang_label;
	gtk_box_pack_start (vbox, (GtkWidget*) _tmp8_, TRUE, FALSE, (guint) 0);
	_tmp9_ = g_menu_new ();
	menu = _tmp9_;
	g_menu_append (menu, _ ("Show emoji variants"), "win.variant");
	_tmp10_ = (GtkMenuButton*) gtk_menu_button_new ();
	g_object_ref_sink (_tmp10_);
	menu_button = _tmp10_;
	gtk_menu_button_set_direction (menu_button, GTK_ARROW_NONE);
	gtk_widget_set_valign ((GtkWidget*) menu_button, GTK_ALIGN_CENTER);
	gtk_menu_button_set_menu_model (menu_button, (GMenuModel*) menu);
	gtk_widget_set_tooltip_text ((GtkWidget*) menu_button, _ ("Menu"));
	gtk_header_bar_pack_end ((GtkHeaderBar*) self, (GtkWidget*) menu_button);
	_g_object_unref0 (menu_button);
	_g_object_unref0 (menu);
	_g_object_unref0 (label);
	_g_object_unref0 (vbox);
	return self;
}


static IBusEmojierETitleLabelBox* ibus_emojier_etitle_label_box_new (const gchar* title) {
	return ibus_emojier_etitle_label_box_construct (IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX, title);
}


static void ibus_emojier_etitle_label_box_set_lang_label (IBusEmojierETitleLabelBox* self, const gchar* str) {
	GtkLabel* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (str != NULL);
	_tmp0_ = self->priv->m_lang_label;
	_tmp1_ = str;
	gtk_label_set_text (_tmp0_, _tmp1_);
}


static void ibus_emojier_etitle_label_box_class_init (IBusEmojierETitleLabelBoxClass * klass) {
	ibus_emojier_etitle_label_box_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IBusEmojierETitleLabelBoxPrivate));
	G_OBJECT_CLASS (klass)->finalize = ibus_emojier_etitle_label_box_finalize;
}


static void ibus_emojier_etitle_label_box_instance_init (IBusEmojierETitleLabelBox * self) {
	self->priv = IBUS_EMOJIER_ETITLE_LABEL_BOX_GET_PRIVATE (self);
}


static void ibus_emojier_etitle_label_box_finalize (GObject * obj) {
	IBusEmojierETitleLabelBox * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, IBUS_EMOJIER_TYPE_ETITLE_LABEL_BOX, IBusEmojierETitleLabelBox);
	_g_object_unref0 (self->priv->m_lang_label);
	G_OBJECT_CLASS (ibus_emojier_etitle_label_box_parent_class)->finalize (obj);
}


static GType ibus_emojier_etitle_label_box_get_type (void) {
	static volatile gsize ibus_emojier_etitle_label_box_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_etitle_label_box_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierETitleLabelBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_etitle_label_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierETitleLabelBox), 0, (GInstanceInitFunc) ibus_emojier_etitle_label_box_instance_init, NULL };
		GType ibus_emojier_etitle_label_box_type_id;
		ibus_emojier_etitle_label_box_type_id = g_type_register_static (gtk_header_bar_get_type (), "IBusEmojierETitleLabelBox", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_etitle_label_box_type_id__volatile, ibus_emojier_etitle_label_box_type_id);
	}
	return ibus_emojier_etitle_label_box_type_id__volatile;
}


static void ibus_emojier_class_init (IBusEmojierClass * klass) {
	ibus_emojier_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IBusEmojierPrivate));
	((GtkWidgetClass *) klass)->show = (void (*) (GtkWidget *)) ibus_emojier_real_show;
	((GtkWidgetClass *) klass)->key_press_event = (gboolean (*) (GtkWidget *, GdkEventKey*)) ibus_emojier_real_key_press_event;
	G_OBJECT_CLASS (klass)->finalize = ibus_emojier_finalize;
	ibus_emojier_signals[IBUS_EMOJIER_CANDIDATE_CLICKED_SIGNAL] = g_signal_new ("candidate-clicked", TYPE_IBUS_EMOJIER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT_UINT_UINT, G_TYPE_NONE, 3, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UINT);
}


static void ibus_emojier_instance_init (IBusEmojier * self) {
	gchar* _tmp0_;
	self->priv = IBUS_EMOJIER_GET_PRIVATE (self);
	self->priv->m_backward_index = -1;
	self->priv->m_scrolled_window = NULL;
	self->priv->m_is_running = FALSE;
	_tmp0_ = g_strdup ("");
	self->priv->m_input_context_path = _tmp0_;
	self->priv->m_unicode_point = NULL;
	self->priv->m_enter_notify_enable = TRUE;
}


static void ibus_emojier_finalize (GObject * obj) {
	IBusEmojier * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_IBUS_EMOJIER, IBusEmojier);
	_themed_rgba_unref0 (self->priv->m_rgba);
	_g_object_unref0 (self->priv->m_vbox);
	_g_object_unref0 (self->priv->m_title);
	_g_object_unref0 (self->priv->m_entry);
	_g_free0 (self->priv->m_backward);
	_g_object_unref0 (self->priv->m_scrolled_window);
	_g_object_unref0 (self->priv->m_list_box);
	_g_free0 (self->priv->m_input_context_path);
	_g_main_loop_unref0 (self->priv->m_loop);
	_g_free0 (self->priv->m_result);
	_g_free0 (self->priv->m_unicode_point);
	_g_object_unref0 (self->priv->m_lookup_table);
	self->priv->m_candidates = (_vala_array_free (self->priv->m_candidates, self->priv->m_candidates_length1, (GDestroyNotify) g_object_unref), NULL);
	G_OBJECT_CLASS (ibus_emojier_parent_class)->finalize (obj);
}


GType ibus_emojier_get_type (void) {
	static volatile gsize ibus_emojier_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojier), 0, (GInstanceInitFunc) ibus_emojier_instance_init, NULL };
		GType ibus_emojier_type_id;
		ibus_emojier_type_id = g_type_register_static (gtk_application_window_get_type (), "IBusEmojier", &g_define_type_info, 0);
		g_once_init_leave (&ibus_emojier_type_id__volatile, ibus_emojier_type_id);
	}
	return ibus_emojier_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



